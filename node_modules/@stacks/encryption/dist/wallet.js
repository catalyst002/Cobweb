"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptMnemonic = exports.encryptMnemonic = void 0;
const bip39_1 = require("@scure/bip39");
const english_1 = require("@scure/bip39/wordlists/english");
const cryptoRandom_1 = require("./cryptoRandom");
const sha2Hash_1 = require("./sha2Hash");
const aesCipher_1 = require("./aesCipher");
const pbkdf2_1 = require("./pbkdf2");
const common_1 = require("@stacks/common");
const ec_1 = require("./ec");
async function encryptMnemonic(phrase, password, opts) {
    let mnemonicEntropy;
    try {
        const entropyBytes = (0, bip39_1.mnemonicToEntropy)(phrase, english_1.wordlist);
        mnemonicEntropy = (0, common_1.bytesToHex)(entropyBytes);
    }
    catch (error) {
        console.error('Invalid mnemonic phrase provided');
        console.error(error);
        throw new Error('Not a valid bip39 mnemonic');
    }
    const plaintextNormalized = (0, common_1.hexToBytes)(mnemonicEntropy);
    const pbkdf2 = await (0, pbkdf2_1.createPbkdf2)();
    const salt = opts?.getRandomBytes ? opts.getRandomBytes(16) : (0, cryptoRandom_1.randomBytes)(16);
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const cipher = await (0, aesCipher_1.createCipher)();
    const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);
    const hmacPayload = (0, common_1.concatBytes)(salt, cipherText);
    const hmacDigest = (0, ec_1.hmacSha256)(macKey, hmacPayload);
    const payload = (0, common_1.concatBytes)(salt, hmacDigest, cipherText);
    return payload;
}
exports.encryptMnemonic = encryptMnemonic;
class PasswordError extends Error {
}
async function decryptMnemonicBytes(dataBytes, password) {
    const salt = dataBytes.slice(0, 16);
    const hmacSig = dataBytes.slice(16, 48);
    const cipherText = dataBytes.slice(48);
    const hmacPayload = (0, common_1.concatBytes)(salt, cipherText);
    const pbkdf2 = await (0, pbkdf2_1.createPbkdf2)();
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const decipher = await (0, aesCipher_1.createCipher)();
    const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);
    const hmacDigest = (0, ec_1.hmacSha256)(macKey, hmacPayload);
    const sha2Hash = await (0, sha2Hash_1.createSha2Hash)();
    const hmacSigHash = await sha2Hash.digest(hmacSig);
    const hmacDigestHash = await sha2Hash.digest(hmacDigest);
    if (!(0, common_1.equals)(hmacSigHash, hmacDigestHash)) {
        throw new PasswordError('Wrong password (HMAC mismatch)');
    }
    let mnemonic;
    try {
        mnemonic = (0, bip39_1.entropyToMnemonic)(decryptedResult, english_1.wordlist);
    }
    catch (error) {
        console.error('Error thrown by `entropyToMnemonic`');
        console.error(error);
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    return mnemonic;
}
function decryptLegacy(dataBytes, password, triplesecDecrypt) {
    return new Promise((resolve, reject) => {
        if (!triplesecDecrypt) {
            reject(new Error('The `triplesec.decrypt` function must be provided'));
        }
        triplesecDecrypt({
            key: (0, common_1.utf8ToBytes)(password),
            data: dataBytes,
        }, (err, plaintextBytes) => {
            if (!err) {
                resolve(plaintextBytes);
            }
            else {
                reject(err);
            }
        });
    });
}
async function decryptMnemonic(data, password, triplesecDecrypt) {
    const dataBytes = typeof data === 'string' ? (0, common_1.hexToBytes)(data) : data;
    try {
        return await decryptMnemonicBytes(dataBytes, password);
    }
    catch (error) {
        if (error instanceof PasswordError)
            throw error;
        const data = await decryptLegacy(dataBytes, password, triplesecDecrypt);
        return (0, common_1.bytesToUtf8)(data);
    }
}
exports.decryptMnemonic = decryptMnemonic;
//# sourceMappingURL=wallet.js.map