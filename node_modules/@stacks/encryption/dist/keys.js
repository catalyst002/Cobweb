"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compressPrivateKey = exports.isValidPrivateKey = exports.ecSign = exports.getPublicKeyFromPrivate = exports.publicKeyToBtcAddress = exports.base58CheckEncode = exports.base58Encode = exports.base58CheckDecode = exports.makeECPrivateKey = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const sha256_1 = require("@noble/hashes/sha256");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
const bs58_1 = __importDefault(require("bs58"));
const hashRipemd160_1 = require("./hashRipemd160");
const sha2Hash_1 = require("./sha2Hash");
const BITCOIN_PUBKEYHASH = 0x00;
secp256k1_1.utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac_1.hmac.create(sha256_1.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function makeECPrivateKey() {
    return (0, common_1.bytesToHex)(secp256k1_1.utils.randomPrivateKey());
}
exports.makeECPrivateKey = makeECPrivateKey;
function base58CheckDecode(btcAddress) {
    const bytes = bs58_1.default.decode(btcAddress);
    const payload = bytes.slice(0, -4);
    const checksum = bytes.slice(-4);
    const newChecksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(payload));
    if ((checksum[0] ^ newChecksum[0]) |
        (checksum[1] ^ newChecksum[1]) |
        (checksum[2] ^ newChecksum[2]) |
        (checksum[3] ^ newChecksum[3])) {
        throw new Error('Invalid checksum');
    }
    if (payload.length !== 21)
        throw new TypeError('Invalid address length');
    const version = (0, common_1.readUInt8)(payload, 0);
    const hash = payload.slice(1);
    return { version, hash };
}
exports.base58CheckDecode = base58CheckDecode;
function base58Encode(hash) {
    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(hash));
    return bs58_1.default.encode((0, common_1.concatBytes)(hash, checksum).slice(0, hash.length + 4));
}
exports.base58Encode = base58Encode;
function base58CheckEncode(version, hash) {
    return base58Encode((0, common_1.concatBytes)(new Uint8Array([version]), hash.slice(0, 20)));
}
exports.base58CheckEncode = base58CheckEncode;
function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {
    const publicKeyBytes = typeof publicKey === 'string' ? (0, common_1.hexToBytes)(publicKey) : publicKey;
    const publicKeyHash160 = (0, hashRipemd160_1.hashRipemd160)((0, sha2Hash_1.hashSha256Sync)(publicKeyBytes));
    return base58CheckEncode(version, publicKeyHash160);
}
exports.publicKeyToBtcAddress = publicKeyToBtcAddress;
function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBytes = (0, common_1.privateKeyToBytes)(privateKey);
    return (0, common_1.bytesToHex)((0, secp256k1_1.getPublicKey)(privateKeyBytes.slice(0, 32), true));
}
exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
function ecSign(messageHash, hexPrivateKey) {
    return (0, secp256k1_1.signSync)(messageHash, (0, common_1.privateKeyToBytes)(hexPrivateKey).slice(0, 32), {
        der: false,
    });
}
exports.ecSign = ecSign;
function isValidPrivateKey(privateKey) {
    return secp256k1_1.utils.isValidPrivateKey((0, common_1.privateKeyToBytes)(privateKey));
}
exports.isValidPrivateKey = isValidPrivateKey;
function compressPrivateKey(privateKey) {
    const privateKeyBytes = (0, common_1.privateKeyToBytes)(privateKey);
    return privateKeyBytes.length == common_1.PRIVATE_KEY_COMPRESSED_LENGTH
        ? privateKeyBytes
        : (0, common_1.concatBytes)(privateKeyBytes, new Uint8Array([1]));
}
exports.compressPrivateKey = compressPrivateKey;
//# sourceMappingURL=keys.js.map