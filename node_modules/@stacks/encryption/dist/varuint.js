"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodingLength = exports.decode = exports.encode = void 0;
const common_1 = require("@stacks/common");
const MAX_SAFE_INTEGER = 9007199254740991;
function ensureUInt53(n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError('value out of range');
}
function encode(number, bytes, offset = 0) {
    ensureUInt53(number);
    if (!bytes)
        bytes = new Uint8Array(encodingLength(number));
    if (number < 0xfd) {
        (0, common_1.writeUInt8)(bytes, number, offset);
    }
    else if (number <= 65535) {
        (0, common_1.writeUInt8)(bytes, 0xfd, offset);
        (0, common_1.writeUInt16LE)(bytes, number, offset + 1);
    }
    else if (number <= 4294967295) {
        (0, common_1.writeUInt8)(bytes, 0xfe, offset);
        (0, common_1.writeUInt32LE)(bytes, number, offset + 1);
    }
    else {
        (0, common_1.writeUInt8)(bytes, 0xff, offset);
        (0, common_1.writeUInt32LE)(bytes, number >>> 0, offset + 1);
        (0, common_1.writeUInt32LE)(bytes, (number / 4294967296) | 0, offset + 5);
    }
    return bytes;
}
exports.encode = encode;
function decode(bytes, offset = 0) {
    const first = (0, common_1.readUInt8)(bytes, offset);
    if (first < 0xfd) {
        return first;
    }
    else if (first === 0xfd) {
        return (0, common_1.readUInt16LE)(bytes, offset + 1);
    }
    else if (first === 0xfe) {
        return (0, common_1.readUInt32LE)(bytes, offset + 1);
    }
    else {
        const lo = (0, common_1.readUInt32LE)(bytes, offset + 1);
        const hi = (0, common_1.readUInt32LE)(bytes, offset + 5);
        const number = hi * 4294967296 + lo;
        ensureUInt53(number);
        return number;
    }
}
exports.decode = decode;
function encodingLength(number) {
    ensureUInt53(number);
    return number < 0xfd ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;
}
exports.encodingLength = encodingLength;
//# sourceMappingURL=varuint.js.map