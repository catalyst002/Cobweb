import { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
import { randomBytes } from './cryptoRandom';
import { createSha2Hash } from './sha2Hash';
import { createCipher } from './aesCipher';
import { createPbkdf2 } from './pbkdf2';
import { bytesToHex, bytesToUtf8, concatBytes, equals, hexToBytes, utf8ToBytes, } from '@stacks/common';
import { hmacSha256 } from './ec';
export async function encryptMnemonic(phrase, password, opts) {
    let mnemonicEntropy;
    try {
        const entropyBytes = mnemonicToEntropy(phrase, wordlist);
        mnemonicEntropy = bytesToHex(entropyBytes);
    }
    catch (error) {
        console.error('Invalid mnemonic phrase provided');
        console.error(error);
        throw new Error('Not a valid bip39 mnemonic');
    }
    const plaintextNormalized = hexToBytes(mnemonicEntropy);
    const pbkdf2 = await createPbkdf2();
    const salt = opts?.getRandomBytes ? opts.getRandomBytes(16) : randomBytes(16);
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const cipher = await createCipher();
    const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);
    const hmacPayload = concatBytes(salt, cipherText);
    const hmacDigest = hmacSha256(macKey, hmacPayload);
    const payload = concatBytes(salt, hmacDigest, cipherText);
    return payload;
}
class PasswordError extends Error {
}
async function decryptMnemonicBytes(dataBytes, password) {
    const salt = dataBytes.slice(0, 16);
    const hmacSig = dataBytes.slice(16, 48);
    const cipherText = dataBytes.slice(48);
    const hmacPayload = concatBytes(salt, cipherText);
    const pbkdf2 = await createPbkdf2();
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const decipher = await createCipher();
    const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);
    const hmacDigest = hmacSha256(macKey, hmacPayload);
    const sha2Hash = await createSha2Hash();
    const hmacSigHash = await sha2Hash.digest(hmacSig);
    const hmacDigestHash = await sha2Hash.digest(hmacDigest);
    if (!equals(hmacSigHash, hmacDigestHash)) {
        throw new PasswordError('Wrong password (HMAC mismatch)');
    }
    let mnemonic;
    try {
        mnemonic = entropyToMnemonic(decryptedResult, wordlist);
    }
    catch (error) {
        console.error('Error thrown by `entropyToMnemonic`');
        console.error(error);
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    if (!validateMnemonic(mnemonic, wordlist)) {
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    return mnemonic;
}
function decryptLegacy(dataBytes, password, triplesecDecrypt) {
    return new Promise((resolve, reject) => {
        if (!triplesecDecrypt) {
            reject(new Error('The `triplesec.decrypt` function must be provided'));
        }
        triplesecDecrypt({
            key: utf8ToBytes(password),
            data: dataBytes,
        }, (err, plaintextBytes) => {
            if (!err) {
                resolve(plaintextBytes);
            }
            else {
                reject(err);
            }
        });
    });
}
export async function decryptMnemonic(data, password, triplesecDecrypt) {
    const dataBytes = typeof data === 'string' ? hexToBytes(data) : data;
    try {
        return await decryptMnemonicBytes(dataBytes, password);
    }
    catch (error) {
        if (error instanceof PasswordError)
            throw error;
        const data = await decryptLegacy(dataBytes, password, triplesecDecrypt);
        return bytesToUtf8(data);
    }
}
//# sourceMappingURL=wallet.js.map