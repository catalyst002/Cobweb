import { readUInt16LE, readUInt32LE, readUInt8, writeUInt16LE, writeUInt32LE, writeUInt8, } from '@stacks/common';
const MAX_SAFE_INTEGER = 9007199254740991;
function ensureUInt53(n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError('value out of range');
}
export function encode(number, bytes, offset = 0) {
    ensureUInt53(number);
    if (!bytes)
        bytes = new Uint8Array(encodingLength(number));
    if (number < 0xfd) {
        writeUInt8(bytes, number, offset);
    }
    else if (number <= 65535) {
        writeUInt8(bytes, 0xfd, offset);
        writeUInt16LE(bytes, number, offset + 1);
    }
    else if (number <= 4294967295) {
        writeUInt8(bytes, 0xfe, offset);
        writeUInt32LE(bytes, number, offset + 1);
    }
    else {
        writeUInt8(bytes, 0xff, offset);
        writeUInt32LE(bytes, number >>> 0, offset + 1);
        writeUInt32LE(bytes, (number / 4294967296) | 0, offset + 5);
    }
    return bytes;
}
export function decode(bytes, offset = 0) {
    const first = readUInt8(bytes, offset);
    if (first < 0xfd) {
        return first;
    }
    else if (first === 0xfd) {
        return readUInt16LE(bytes, offset + 1);
    }
    else if (first === 0xfe) {
        return readUInt32LE(bytes, offset + 1);
    }
    else {
        const lo = readUInt32LE(bytes, offset + 1);
        const hi = readUInt32LE(bytes, offset + 5);
        const number = hi * 4294967296 + lo;
        ensureUInt53(number);
        return number;
    }
}
export function encodingLength(number) {
    ensureUInt53(number);
    return number < 0xfd ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;
}
//# sourceMappingURL=varuint.js.map