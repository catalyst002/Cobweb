"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeTransaction = exports.StacksTransaction = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const authorization_1 = require("./authorization");
const signature_1 = require("./signature");
const utils_1 = require("./utils");
const payload_1 = require("./payload");
const types_1 = require("./types");
const keys_1 = require("./keys");
const bytesReader_1 = require("./bytesReader");
const errors_1 = require("./errors");
class StacksTransaction {
    constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {
        this.version = version;
        this.auth = auth;
        if ('amount' in payload) {
            this.payload = {
                ...payload,
                amount: (0, common_1.intToBigInt)(payload.amount, false),
            };
        }
        else {
            this.payload = payload;
        }
        this.chainId = chainId ?? constants_1.DEFAULT_CHAIN_ID;
        this.postConditionMode = postConditionMode ?? constants_1.PostConditionMode.Deny;
        this.postConditions = postConditions ?? (0, types_1.createLPList)([]);
        if (anchorMode) {
            this.anchorMode = (0, constants_1.anchorModeFromNameOrValue)(anchorMode);
        }
        else {
            switch (payload.payloadType) {
                case constants_1.PayloadType.Coinbase:
                case constants_1.PayloadType.CoinbaseToAltRecipient:
                case constants_1.PayloadType.PoisonMicroblock: {
                    this.anchorMode = constants_1.AnchorMode.OnChainOnly;
                    break;
                }
                case constants_1.PayloadType.ContractCall:
                case constants_1.PayloadType.SmartContract:
                case constants_1.PayloadType.VersionedSmartContract:
                case constants_1.PayloadType.TokenTransfer: {
                    this.anchorMode = constants_1.AnchorMode.Any;
                    break;
                }
            }
        }
    }
    signBegin() {
        const tx = (0, utils_1.cloneDeep)(this);
        tx.auth = (0, authorization_1.intoInitialSighashAuth)(tx.auth);
        return tx.txid();
    }
    verifyBegin() {
        const tx = (0, utils_1.cloneDeep)(this);
        tx.auth = (0, authorization_1.intoInitialSighashAuth)(tx.auth);
        return tx.txid();
    }
    verifyOrigin() {
        return (0, authorization_1.verifyOrigin)(this.auth, this.verifyBegin());
    }
    signNextOrigin(sigHash, privateKey) {
        if (this.auth.spendingCondition === undefined) {
            throw new Error('"auth.spendingCondition" is undefined');
        }
        if (this.auth.authType === undefined) {
            throw new Error('"auth.authType" is undefined');
        }
        return this.signAndAppend(this.auth.spendingCondition, sigHash, constants_1.AuthType.Standard, privateKey);
    }
    signNextSponsor(sigHash, privateKey) {
        if (this.auth.authType === constants_1.AuthType.Sponsored) {
            return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, constants_1.AuthType.Sponsored, privateKey);
        }
        else {
            throw new Error('"auth.sponsorSpendingCondition" is undefined');
        }
    }
    appendPubkey(publicKey) {
        const cond = this.auth.spendingCondition;
        if (cond && !(0, authorization_1.isSingleSig)(cond)) {
            const compressed = (0, keys_1.isCompressed)(publicKey);
            cond.fields.push((0, signature_1.createTransactionAuthField)(compressed ? constants_1.PubKeyEncoding.Compressed : constants_1.PubKeyEncoding.Uncompressed, publicKey));
        }
        else {
            throw new Error(`Can't append public key to a singlesig condition`);
        }
    }
    signAndAppend(condition, curSigHash, authType, privateKey) {
        const { nextSig, nextSigHash } = (0, authorization_1.nextSignature)(curSigHash, authType, condition.fee, condition.nonce, privateKey);
        if ((0, authorization_1.isSingleSig)(condition)) {
            condition.signature = nextSig;
        }
        else {
            const compressed = (0, common_1.bytesToHex)(privateKey.data).endsWith('01');
            condition.fields.push((0, signature_1.createTransactionAuthField)(compressed ? constants_1.PubKeyEncoding.Compressed : constants_1.PubKeyEncoding.Uncompressed, nextSig));
        }
        return nextSigHash;
    }
    txid() {
        const serialized = this.serialize();
        return (0, utils_1.txidFromData)(serialized);
    }
    setSponsor(sponsorSpendingCondition) {
        if (this.auth.authType != constants_1.AuthType.Sponsored) {
            throw new errors_1.SigningError('Cannot sponsor sign a non-sponsored transaction');
        }
        this.auth = (0, authorization_1.setSponsor)(this.auth, sponsorSpendingCondition);
    }
    setFee(amount) {
        this.auth = (0, authorization_1.setFee)(this.auth, amount);
    }
    setNonce(nonce) {
        this.auth = (0, authorization_1.setNonce)(this.auth, nonce);
    }
    setSponsorNonce(nonce) {
        if (this.auth.authType != constants_1.AuthType.Sponsored) {
            throw new errors_1.SigningError('Cannot sponsor sign a non-sponsored transaction');
        }
        this.auth = (0, authorization_1.setSponsorNonce)(this.auth, nonce);
    }
    serialize() {
        if (this.version === undefined) {
            throw new errors_1.SerializationError('"version" is undefined');
        }
        if (this.chainId === undefined) {
            throw new errors_1.SerializationError('"chainId" is undefined');
        }
        if (this.auth === undefined) {
            throw new errors_1.SerializationError('"auth" is undefined');
        }
        if (this.anchorMode === undefined) {
            throw new errors_1.SerializationError('"anchorMode" is undefined');
        }
        if (this.payload === undefined) {
            throw new errors_1.SerializationError('"payload" is undefined');
        }
        const bytesArray = [];
        bytesArray.push(this.version);
        const chainIdBytes = new Uint8Array(4);
        (0, common_1.writeUInt32BE)(chainIdBytes, this.chainId, 0);
        bytesArray.push(chainIdBytes);
        bytesArray.push((0, authorization_1.serializeAuthorization)(this.auth));
        bytesArray.push(this.anchorMode);
        bytesArray.push(this.postConditionMode);
        bytesArray.push((0, types_1.serializeLPList)(this.postConditions));
        bytesArray.push((0, payload_1.serializePayload)(this.payload));
        return (0, common_1.concatArray)(bytesArray);
    }
}
exports.StacksTransaction = StacksTransaction;
function deserializeTransaction(data) {
    let bytesReader;
    if (typeof data === 'string') {
        if (data.slice(0, 2).toLowerCase() === '0x') {
            bytesReader = new bytesReader_1.BytesReader((0, common_1.hexToBytes)(data.slice(2)));
        }
        else {
            bytesReader = new bytesReader_1.BytesReader((0, common_1.hexToBytes)(data));
        }
    }
    else if (data instanceof Uint8Array) {
        bytesReader = new bytesReader_1.BytesReader(data);
    }
    else {
        bytesReader = data;
    }
    const version = bytesReader.readUInt8Enum(constants_1.TransactionVersion, n => {
        throw new Error(`Could not parse ${n} as TransactionVersion`);
    });
    const chainId = bytesReader.readUInt32BE();
    const auth = (0, authorization_1.deserializeAuthorization)(bytesReader);
    const anchorMode = bytesReader.readUInt8Enum(constants_1.AnchorMode, n => {
        throw new Error(`Could not parse ${n} as AnchorMode`);
    });
    const postConditionMode = bytesReader.readUInt8Enum(constants_1.PostConditionMode, n => {
        throw new Error(`Could not parse ${n} as PostConditionMode`);
    });
    const postConditions = (0, types_1.deserializeLPList)(bytesReader, constants_1.StacksMessageType.PostCondition);
    const payload = (0, payload_1.deserializePayload)(bytesReader);
    return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);
}
exports.deserializeTransaction = deserializeTransaction;
//# sourceMappingURL=transaction.js.map