"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.principal = void 0;
const builders_1 = require("./builders");
const constants_1 = require("./constants");
const postcondition_types_1 = require("./postcondition-types");
function principal(principal) {
    if (isContractIdString(principal)) {
        const [address, name] = parseContractId(principal);
        return new PartialPcWithPrincipal(address, name);
    }
    return new PartialPcWithPrincipal(principal, undefined);
}
exports.principal = principal;
class PartialPcWithPrincipal {
    constructor(address, contractName) {
        this.address = address;
        this.contractName = contractName;
    }
    willSendEq(amount) {
        return new PartialPcFtWithCode(this.address, amount, constants_1.FungibleConditionCode.Equal, this.contractName);
    }
    willSendLte(amount) {
        return new PartialPcFtWithCode(this.address, amount, constants_1.FungibleConditionCode.LessEqual, this.contractName);
    }
    willSendLt(amount) {
        return new PartialPcFtWithCode(this.address, amount, constants_1.FungibleConditionCode.Less, this.contractName);
    }
    willSendGte(amount) {
        return new PartialPcFtWithCode(this.address, amount, constants_1.FungibleConditionCode.GreaterEqual, this.contractName);
    }
    willSendGt(amount) {
        return new PartialPcFtWithCode(this.address, amount, constants_1.FungibleConditionCode.Greater, this.contractName);
    }
    willSendAsset() {
        return new PartialPcNftWithCode(this.address, constants_1.NonFungibleConditionCode.Sends, this.contractName);
    }
    willNotSendAsset() {
        return new PartialPcNftWithCode(this.address, constants_1.NonFungibleConditionCode.DoesNotSend, this.contractName);
    }
}
class PartialPcFtWithCode {
    constructor(address, amount, code, contractName) {
        this.address = address;
        this.amount = amount;
        this.code = code;
        this.contractName = contractName;
    }
    ustx() {
        if (this.contractName) {
            return (0, builders_1.makeContractSTXPostCondition)(this.address, this.contractName, this.code, this.amount);
        }
        return (0, builders_1.makeStandardSTXPostCondition)(this.address, this.code, this.amount);
    }
    ft(contractId, tokenName) {
        const [address, name] = parseContractId(contractId);
        if (this.contractName) {
            return (0, builders_1.makeContractFungiblePostCondition)(this.address, this.contractName, this.code, this.amount, (0, postcondition_types_1.createAssetInfo)(address, name, tokenName));
        }
        return (0, builders_1.makeStandardFungiblePostCondition)(this.address, this.code, this.amount, (0, postcondition_types_1.createAssetInfo)(address, name, tokenName));
    }
}
class PartialPcNftWithCode {
    constructor(principal, code, contractName) {
        this.principal = principal;
        this.code = code;
        this.contractName = contractName;
    }
    nft(...args) {
        const { contractAddress, contractName, tokenName, assetId } = getNftArgs(...args);
        if (this.contractName) {
            return (0, builders_1.makeContractNonFungiblePostCondition)(this.principal, this.contractName, this.code, (0, postcondition_types_1.createAssetInfo)(contractAddress, contractName, tokenName), assetId);
        }
        return (0, builders_1.makeStandardNonFungiblePostCondition)(this.principal, this.code, (0, postcondition_types_1.createAssetInfo)(contractAddress, contractName, tokenName), assetId);
    }
}
function parseContractId(contractId) {
    const [address, name] = contractId.split('.');
    if (!address || !name)
        throw new Error(`Invalid contract identifier: ${contractId}`);
    return [address, name];
}
function parseNft(nftAssetName) {
    const [principal, tokenName] = nftAssetName.split('::');
    if (!principal || !tokenName)
        throw new Error(`Invalid fully-qualified nft asset name: ${nftAssetName}`);
    const [address, name] = parseContractId(principal);
    return { contractAddress: address, contractName: name, tokenName };
}
function isContractIdString(value) {
    return value.includes('.');
}
function getNftArgs(...args) {
    if (args.length === 2) {
        const [assetName, assetId] = args;
        return { ...parseNft(assetName), assetId };
    }
    const [contractId, tokenName, assetId] = args;
    const [address, name] = parseContractId(contractId);
    return { contractAddress: address, contractName: name, tokenName, assetId };
}
//# sourceMappingURL=pc.js.map