"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializePayload = exports.serializePayload = exports.createCoinbasePayload = exports.createPoisonPayload = exports.createSmartContractPayload = exports.createContractCallPayload = exports.createTokenTransferPayload = exports.isCoinbasePayload = exports.isPoisonPayload = exports.isSmartContractPayload = exports.isContractCallPayload = exports.isTokenTransferPayload = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const clarity_1 = require("./clarity/");
const principalCV_1 = require("./clarity/types/principalCV");
const postcondition_types_1 = require("./postcondition-types");
const types_1 = require("./types");
function isTokenTransferPayload(p) {
    return p.payloadType === constants_1.PayloadType.TokenTransfer;
}
exports.isTokenTransferPayload = isTokenTransferPayload;
function isContractCallPayload(p) {
    return p.payloadType === constants_1.PayloadType.ContractCall;
}
exports.isContractCallPayload = isContractCallPayload;
function isSmartContractPayload(p) {
    return p.payloadType === constants_1.PayloadType.SmartContract;
}
exports.isSmartContractPayload = isSmartContractPayload;
function isPoisonPayload(p) {
    return p.payloadType === constants_1.PayloadType.PoisonMicroblock;
}
exports.isPoisonPayload = isPoisonPayload;
function isCoinbasePayload(p) {
    return p.payloadType === constants_1.PayloadType.Coinbase;
}
exports.isCoinbasePayload = isCoinbasePayload;
function createTokenTransferPayload(recipient, amount, memo) {
    if (typeof recipient === 'string') {
        recipient = (0, principalCV_1.principalCV)(recipient);
    }
    if (typeof memo === 'string') {
        memo = (0, types_1.createMemoString)(memo);
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.TokenTransfer,
        recipient,
        amount: (0, common_1.intToBigInt)(amount, false),
        memo: memo ?? (0, types_1.createMemoString)(''),
    };
}
exports.createTokenTransferPayload = createTokenTransferPayload;
function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {
    if (typeof contractAddress === 'string') {
        contractAddress = (0, postcondition_types_1.createAddress)(contractAddress);
    }
    if (typeof contractName === 'string') {
        contractName = (0, postcondition_types_1.createLPString)(contractName);
    }
    if (typeof functionName === 'string') {
        functionName = (0, postcondition_types_1.createLPString)(functionName);
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.ContractCall,
        contractAddress,
        contractName,
        functionName,
        functionArgs,
    };
}
exports.createContractCallPayload = createContractCallPayload;
function createSmartContractPayload(contractName, codeBody, clarityVersion) {
    if (typeof contractName === 'string') {
        contractName = (0, postcondition_types_1.createLPString)(contractName);
    }
    if (typeof codeBody === 'string') {
        codeBody = (0, types_1.codeBodyString)(codeBody);
    }
    if (typeof clarityVersion === 'number') {
        return {
            type: constants_1.StacksMessageType.Payload,
            payloadType: constants_1.PayloadType.VersionedSmartContract,
            clarityVersion,
            contractName,
            codeBody,
        };
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.SmartContract,
        contractName,
        codeBody,
    };
}
exports.createSmartContractPayload = createSmartContractPayload;
function createPoisonPayload() {
    return { type: constants_1.StacksMessageType.Payload, payloadType: constants_1.PayloadType.PoisonMicroblock };
}
exports.createPoisonPayload = createPoisonPayload;
function createCoinbasePayload(coinbaseBytes, altRecipient) {
    if (coinbaseBytes.byteLength != constants_1.COINBASE_BYTES_LENGTH) {
        throw Error(`Coinbase buffer size must be ${constants_1.COINBASE_BYTES_LENGTH} bytes`);
    }
    if (altRecipient != undefined) {
        return {
            type: constants_1.StacksMessageType.Payload,
            payloadType: constants_1.PayloadType.CoinbaseToAltRecipient,
            coinbaseBytes,
            recipient: altRecipient,
        };
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.Coinbase,
        coinbaseBytes,
    };
}
exports.createCoinbasePayload = createCoinbasePayload;
function serializePayload(payload) {
    const bytesArray = [];
    bytesArray.push(payload.payloadType);
    switch (payload.payloadType) {
        case constants_1.PayloadType.TokenTransfer:
            bytesArray.push((0, clarity_1.serializeCV)(payload.recipient));
            bytesArray.push((0, common_1.intToBytes)(payload.amount, false, 8));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.memo));
            break;
        case constants_1.PayloadType.ContractCall:
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractAddress));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractName));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.functionName));
            const numArgs = new Uint8Array(4);
            (0, common_1.writeUInt32BE)(numArgs, payload.functionArgs.length, 0);
            bytesArray.push(numArgs);
            payload.functionArgs.forEach(arg => {
                bytesArray.push((0, clarity_1.serializeCV)(arg));
            });
            break;
        case constants_1.PayloadType.SmartContract:
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractName));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.codeBody));
            break;
        case constants_1.PayloadType.VersionedSmartContract:
            bytesArray.push(payload.clarityVersion);
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractName));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.codeBody));
            break;
        case constants_1.PayloadType.PoisonMicroblock:
            break;
        case constants_1.PayloadType.Coinbase:
            bytesArray.push(payload.coinbaseBytes);
            break;
        case constants_1.PayloadType.CoinbaseToAltRecipient:
            bytesArray.push(payload.coinbaseBytes);
            bytesArray.push((0, clarity_1.serializeCV)(payload.recipient));
            break;
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializePayload = serializePayload;
function deserializePayload(bytesReader) {
    const payloadType = bytesReader.readUInt8Enum(constants_1.PayloadType, n => {
        throw new Error(`Cannot recognize PayloadType: ${n}`);
    });
    switch (payloadType) {
        case constants_1.PayloadType.TokenTransfer:
            const recipient = (0, clarity_1.deserializeCV)(bytesReader);
            const amount = (0, common_1.intToBigInt)(bytesReader.readBytes(8), false);
            const memo = (0, types_1.deserializeMemoString)(bytesReader);
            return createTokenTransferPayload(recipient, amount, memo);
        case constants_1.PayloadType.ContractCall:
            const contractAddress = (0, types_1.deserializeAddress)(bytesReader);
            const contractCallName = (0, types_1.deserializeLPString)(bytesReader);
            const functionName = (0, types_1.deserializeLPString)(bytesReader);
            const functionArgs = [];
            const numberOfArgs = bytesReader.readUInt32BE();
            for (let i = 0; i < numberOfArgs; i++) {
                const clarityValue = (0, clarity_1.deserializeCV)(bytesReader);
                functionArgs.push(clarityValue);
            }
            return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);
        case constants_1.PayloadType.SmartContract:
            const smartContractName = (0, types_1.deserializeLPString)(bytesReader);
            const codeBody = (0, types_1.deserializeLPString)(bytesReader, 4, 100000);
            return createSmartContractPayload(smartContractName, codeBody);
        case constants_1.PayloadType.VersionedSmartContract: {
            const clarityVersion = bytesReader.readUInt8Enum(constants_1.ClarityVersion, n => {
                throw new Error(`Cannot recognize ClarityVersion: ${n}`);
            });
            const smartContractName = (0, types_1.deserializeLPString)(bytesReader);
            const codeBody = (0, types_1.deserializeLPString)(bytesReader, 4, 100000);
            return createSmartContractPayload(smartContractName, codeBody, clarityVersion);
        }
        case constants_1.PayloadType.PoisonMicroblock:
            return createPoisonPayload();
        case constants_1.PayloadType.Coinbase:
            const coinbaseBytes = bytesReader.readBytes(constants_1.COINBASE_BYTES_LENGTH);
            return createCoinbasePayload(coinbaseBytes);
        case constants_1.PayloadType.CoinbaseToAltRecipient:
            const coinbaseToAltRecipientBuffer = bytesReader.readBytes(constants_1.COINBASE_BYTES_LENGTH);
            const altRecipient = (0, clarity_1.deserializeCV)(bytesReader);
            return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);
    }
}
exports.deserializePayload = deserializePayload;
//# sourceMappingURL=payload.js.map