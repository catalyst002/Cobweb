import { sha256 } from '@noble/hashes/sha256';
import { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';
import { ClarityType, serializeCV } from './clarity';
import { StacksMessageType } from './constants';
import { signMessageHashRsv } from './keys';
export const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);
export function hashStructuredData(structuredData) {
    return sha256(serializeCV(structuredData));
}
const hash256BytesLength = 32;
function isDomain(value) {
    if (value.type !== ClarityType.Tuple)
        return false;
    if (!['name', 'version', 'chain-id'].every(key => key in value.data))
        return false;
    if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))
        return false;
    if (value.data['chain-id'].type !== ClarityType.UInt)
        return false;
    return true;
}
export function encodeStructuredData({ message, domain, }) {
    const structuredDataHash = hashStructuredData(message);
    if (!isDomain(domain)) {
        throw new Error("domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt");
    }
    const domainHash = hashStructuredData(domain);
    return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);
}
export function decodeStructuredDataSignature(signature) {
    const encodedMessageBytes = typeof signature === 'string' ? utf8ToBytes(signature) : signature;
    const domainHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    return {
        domainHash,
        messageHash,
    };
}
export function signStructuredData({ message, domain, privateKey, }) {
    const structuredDataHash = bytesToHex(sha256(encodeStructuredData({ message, domain })));
    const { data } = signMessageHashRsv({
        messageHash: structuredDataHash,
        privateKey,
    });
    return {
        data,
        type: StacksMessageType.StructuredDataSignature,
    };
}
//# sourceMappingURL=structuredDataSignature.js.map