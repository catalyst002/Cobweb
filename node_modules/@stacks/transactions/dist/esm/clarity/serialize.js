import { concatArray, concatBytes, bigIntToBytes, toTwos, writeUInt32BE, utf8ToBytes, asciiToBytes, } from '@stacks/common';
import { serializeAddress, serializeLPString } from '../types';
import { createLPString } from '../postcondition-types';
import { ClarityType } from './constants';
import { SerializationError } from '../errors';
import { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';
function bytesWithTypeID(typeId, bytes) {
    return concatArray([typeId, bytes]);
}
function serializeBoolCV(value) {
    return new Uint8Array([value.type]);
}
function serializeOptionalCV(cv) {
    if (cv.type === ClarityType.OptionalNone) {
        return new Uint8Array([cv.type]);
    }
    else {
        return bytesWithTypeID(cv.type, serializeCV(cv.value));
    }
}
function serializeBufferCV(cv) {
    const length = new Uint8Array(4);
    writeUInt32BE(length, cv.buffer.length, 0);
    return bytesWithTypeID(cv.type, concatBytes(length, cv.buffer));
}
function serializeIntCV(cv) {
    const bytes = bigIntToBytes(toTwos(cv.value, BigInt(CLARITY_INT_SIZE)), CLARITY_INT_BYTE_SIZE);
    return bytesWithTypeID(cv.type, bytes);
}
function serializeUIntCV(cv) {
    const bytes = bigIntToBytes(cv.value, CLARITY_INT_BYTE_SIZE);
    return bytesWithTypeID(cv.type, bytes);
}
function serializeStandardPrincipalCV(cv) {
    return bytesWithTypeID(cv.type, serializeAddress(cv.address));
}
function serializeContractPrincipalCV(cv) {
    return bytesWithTypeID(cv.type, concatBytes(serializeAddress(cv.address), serializeLPString(cv.contractName)));
}
function serializeResponseCV(cv) {
    return bytesWithTypeID(cv.type, serializeCV(cv.value));
}
function serializeListCV(cv) {
    const bytesArray = [];
    const length = new Uint8Array(4);
    writeUInt32BE(length, cv.list.length, 0);
    bytesArray.push(length);
    for (const value of cv.list) {
        const serializedValue = serializeCV(value);
        bytesArray.push(serializedValue);
    }
    return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeTupleCV(cv) {
    const bytesArray = [];
    const length = new Uint8Array(4);
    writeUInt32BE(length, Object.keys(cv.data).length, 0);
    bytesArray.push(length);
    const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));
    for (const key of lexicographicOrder) {
        const nameWithLength = createLPString(key);
        bytesArray.push(serializeLPString(nameWithLength));
        const serializedValue = serializeCV(cv.data[key]);
        bytesArray.push(serializedValue);
    }
    return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringCV(cv, encoding) {
    const bytesArray = [];
    const str = encoding == 'ascii' ? asciiToBytes(cv.data) : utf8ToBytes(cv.data);
    const len = new Uint8Array(4);
    writeUInt32BE(len, str.length, 0);
    bytesArray.push(len);
    bytesArray.push(str);
    return bytesWithTypeID(cv.type, concatArray(bytesArray));
}
function serializeStringAsciiCV(cv) {
    return serializeStringCV(cv, 'ascii');
}
function serializeStringUtf8CV(cv) {
    return serializeStringCV(cv, 'utf8');
}
export function serializeCV(value) {
    switch (value.type) {
        case ClarityType.BoolTrue:
        case ClarityType.BoolFalse:
            return serializeBoolCV(value);
        case ClarityType.OptionalNone:
        case ClarityType.OptionalSome:
            return serializeOptionalCV(value);
        case ClarityType.Buffer:
            return serializeBufferCV(value);
        case ClarityType.UInt:
            return serializeUIntCV(value);
        case ClarityType.Int:
            return serializeIntCV(value);
        case ClarityType.PrincipalStandard:
            return serializeStandardPrincipalCV(value);
        case ClarityType.PrincipalContract:
            return serializeContractPrincipalCV(value);
        case ClarityType.ResponseOk:
        case ClarityType.ResponseErr:
            return serializeResponseCV(value);
        case ClarityType.List:
            return serializeListCV(value);
        case ClarityType.Tuple:
            return serializeTupleCV(value);
        case ClarityType.StringASCII:
            return serializeStringAsciiCV(value);
        case ClarityType.StringUTF8:
            return serializeStringUtf8CV(value);
        default:
            throw new SerializationError('Unable to serialize. Invalid Clarity Value.');
    }
}
//# sourceMappingURL=serialize.js.map