import { IntegerType } from '@stacks/common';
import { ClarityVersion, PayloadType, StacksMessageType } from './constants';
import { BytesReader } from './bytesReader';
import { ClarityValue } from './clarity/';
import { PrincipalCV } from './clarity/types/principalCV';
import { Address } from './common';
import { LengthPrefixedString } from './postcondition-types';
import { MemoString } from './types';
export type Payload = TokenTransferPayload | ContractCallPayload | SmartContractPayload | VersionedSmartContractPayload | PoisonPayload | CoinbasePayload | CoinbasePayloadToAltRecipient;
export declare function isTokenTransferPayload(p: Payload): p is TokenTransferPayload;
export declare function isContractCallPayload(p: Payload): p is ContractCallPayload;
export declare function isSmartContractPayload(p: Payload): p is SmartContractPayload;
export declare function isPoisonPayload(p: Payload): p is PoisonPayload;
export declare function isCoinbasePayload(p: Payload): p is CoinbasePayload;
export interface TokenTransferPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.TokenTransfer;
    readonly recipient: PrincipalCV;
    readonly amount: bigint;
    readonly memo: MemoString;
}
export type PayloadInput = (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & {
    amount: IntegerType;
})) | ContractCallPayload | SmartContractPayload | VersionedSmartContractPayload | PoisonPayload | CoinbasePayload | CoinbasePayloadToAltRecipient;
export declare function createTokenTransferPayload(recipient: string | PrincipalCV, amount: IntegerType, memo?: string | MemoString): TokenTransferPayload;
export interface ContractCallPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.ContractCall;
    readonly contractAddress: Address;
    readonly contractName: LengthPrefixedString;
    readonly functionName: LengthPrefixedString;
    readonly functionArgs: ClarityValue[];
}
export declare function createContractCallPayload(contractAddress: string | Address, contractName: string | LengthPrefixedString, functionName: string | LengthPrefixedString, functionArgs: ClarityValue[]): ContractCallPayload;
export interface SmartContractPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.SmartContract;
    readonly contractName: LengthPrefixedString;
    readonly codeBody: LengthPrefixedString;
}
export interface VersionedSmartContractPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.VersionedSmartContract;
    readonly clarityVersion: ClarityVersion;
    readonly contractName: LengthPrefixedString;
    readonly codeBody: LengthPrefixedString;
}
export declare function createSmartContractPayload(contractName: string | LengthPrefixedString, codeBody: string | LengthPrefixedString, clarityVersion?: ClarityVersion): SmartContractPayload | VersionedSmartContractPayload;
export interface PoisonPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.PoisonMicroblock;
}
export declare function createPoisonPayload(): PoisonPayload;
export interface CoinbasePayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.Coinbase;
    readonly coinbaseBytes: Uint8Array;
}
export interface CoinbasePayloadToAltRecipient {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.CoinbaseToAltRecipient;
    readonly coinbaseBytes: Uint8Array;
    readonly recipient: PrincipalCV;
}
export declare function createCoinbasePayload(coinbaseBytes: Uint8Array, altRecipient?: PrincipalCV): CoinbasePayload | CoinbasePayloadToAltRecipient;
export declare function serializePayload(payload: PayloadInput): Uint8Array;
export declare function deserializePayload(bytesReader: BytesReader): Payload;
