import { IntegerType } from '@stacks/common';
import { ClarityValue } from './clarity';
import { FungibleConditionCode, NonFungibleConditionCode } from './constants';
import { NonFungiblePostCondition } from './postcondition-types';
type AddressString = string;
type ContractIdString = `${string}.${string}`;
type NftString = `${ContractIdString}::${string}`;
export declare function principal(principal: AddressString | ContractIdString): PartialPcWithPrincipal;
declare class PartialPcWithPrincipal {
    private address;
    private contractName?;
    constructor(address: string, contractName?: string | undefined);
    willSendEq(amount: IntegerType): PartialPcFtWithCode;
    willSendLte(amount: IntegerType): PartialPcFtWithCode;
    willSendLt(amount: IntegerType): PartialPcFtWithCode;
    willSendGte(amount: IntegerType): PartialPcFtWithCode;
    willSendGt(amount: IntegerType): PartialPcFtWithCode;
    willSendAsset(): PartialPcNftWithCode;
    willNotSendAsset(): PartialPcNftWithCode;
}
declare class PartialPcFtWithCode {
    private address;
    private amount;
    private code;
    private contractName?;
    constructor(address: string, amount: IntegerType, code: FungibleConditionCode, contractName?: string | undefined);
    ustx(): import("./postcondition-types").STXPostCondition;
    ft(contractId: ContractIdString, tokenName: string): import("./postcondition-types").FungiblePostCondition;
}
declare class PartialPcNftWithCode {
    private principal;
    private code;
    private contractName?;
    constructor(principal: string, code: NonFungibleConditionCode, contractName?: string | undefined);
    nft(assetName: NftString, assetId: ClarityValue): NonFungiblePostCondition;
    nft(contractId: ContractIdString, tokenName: string, assetId: ClarityValue): NonFungiblePostCondition;
}
export {};
