"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeTransactionAuthField = exports.serializeMessageSignature = exports.deserializeTransactionAuthField = exports.createTransactionAuthField = exports.deserializeMessageSignature = exports.AuthFieldType = void 0;
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const common_1 = require("./common");
const common_2 = require("@stacks/common");
var AuthFieldType;
(function (AuthFieldType) {
    AuthFieldType[AuthFieldType["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
    AuthFieldType[AuthFieldType["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
    AuthFieldType[AuthFieldType["SignatureCompressed"] = 2] = "SignatureCompressed";
    AuthFieldType[AuthFieldType["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType || (exports.AuthFieldType = AuthFieldType = {}));
function deserializeMessageSignature(bytesReader) {
    return (0, common_1.createMessageSignature)((0, common_2.bytesToHex)(bytesReader.readBytes(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)));
}
exports.deserializeMessageSignature = deserializeMessageSignature;
function createTransactionAuthField(pubKeyEncoding, contents) {
    return {
        pubKeyEncoding,
        type: constants_1.StacksMessageType.TransactionAuthField,
        contents,
    };
}
exports.createTransactionAuthField = createTransactionAuthField;
function deserializeTransactionAuthField(bytesReader) {
    const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as AuthFieldType`);
    });
    switch (authFieldType) {
        case AuthFieldType.PublicKeyCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, (0, keys_1.deserializePublicKey)(bytesReader));
        case AuthFieldType.PublicKeyUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, (0, keys_1.deserializePublicKey)(bytesReader));
        case AuthFieldType.SignatureCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, deserializeMessageSignature(bytesReader));
        case AuthFieldType.SignatureUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, deserializeMessageSignature(bytesReader));
        default:
            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
    }
}
exports.deserializeTransactionAuthField = deserializeTransactionAuthField;
function serializeMessageSignature(messageSignature) {
    return (0, common_2.hexToBytes)(messageSignature.data);
}
exports.serializeMessageSignature = serializeMessageSignature;
function serializeTransactionAuthField(field) {
    const bytesArray = [];
    switch (field.contents.type) {
        case constants_1.StacksMessageType.PublicKey:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bytesArray.push(AuthFieldType.PublicKeyCompressed);
                bytesArray.push((0, keys_1.serializePublicKey)(field.contents));
            }
            else {
                bytesArray.push(AuthFieldType.PublicKeyUncompressed);
                bytesArray.push((0, keys_1.serializePublicKey)((0, keys_1.compressPublicKey)(field.contents.data)));
            }
            break;
        case constants_1.StacksMessageType.MessageSignature:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bytesArray.push(AuthFieldType.SignatureCompressed);
            }
            else {
                bytesArray.push(AuthFieldType.SignatureUncompressed);
            }
            bytesArray.push(serializeMessageSignature(field.contents));
            break;
    }
    return (0, common_2.concatArray)(bytesArray);
}
exports.serializeTransactionAuthField = serializeTransactionAuthField;
//# sourceMappingURL=signature.js.map