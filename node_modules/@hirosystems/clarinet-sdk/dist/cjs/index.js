"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initSimnet = exports.tx = void 0;
const transactions_1 = require("@stacks/transactions");
const clarinet_sdk_wasm_1 = require("@hirosystems/clarinet-sdk-wasm");
const vfs_js_1 = require("./vfs.js");
const wasmModule = Promise.resolve().then(() => __importStar(require("@hirosystems/clarinet-sdk-wasm")));
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json
// @ts-ignore
BigInt.prototype.toJSON = function () {
    return this.toString();
};
exports.tx = {
    callPublicFn: (contract, method, args, sender) => ({
        callPublicFn: { contract, method, args, sender },
    }),
    deployContract: (name, content, options, sender) => ({
        deployContract: { name, content, options, sender },
    }),
    transferSTX: (amount, recipient, sender) => ({
        transferSTX: { amount, recipient, sender },
    }),
};
function parseEvents(events) {
    try {
        // @todo: improve type safety
        return JSON.parse(events).map((e) => {
            const { event, data } = JSON.parse(e);
            if ("raw_value" in data) {
                data.value = transactions_1.Cl.deserialize(data.raw_value);
            }
            return {
                event: event,
                data: data,
            };
        });
    }
    catch (e) {
        console.error(`Fail to parse events: ${e}`);
        return [];
    }
}
function parseTxResponse(response) {
    return {
        result: transactions_1.Cl.deserialize(response.result),
        events: parseEvents(response.events),
    };
}
const getSessionProxy = () => ({
    get(session, prop, receiver) {
        // some of the WASM methods are proxied here to:
        // - serialize clarity values input argument
        // - deserialize output into clarity values
        if (prop === "callReadOnlyFn" || prop === "callPublicFn") {
            const callFn = (contract, method, args, sender) => {
                const response = session[prop](new clarinet_sdk_wasm_1.CallContractArgs(contract, method, args.map((a) => transactions_1.Cl.serialize(a)), sender));
                return parseTxResponse(response);
            };
            return callFn;
        }
        if (prop === "deployContract") {
            const callDeployContract = (name, content, options, sender) => {
                const rustOptions = options
                    ? new clarinet_sdk_wasm_1.ContractOptions(options.clarityVersion)
                    : new clarinet_sdk_wasm_1.ContractOptions();
                const response = session.deployContract(new clarinet_sdk_wasm_1.DeployContractArgs(name, content, rustOptions, sender));
                return parseTxResponse(response);
            };
            return callDeployContract;
        }
        if (prop === "transferSTX") {
            const callTransferSTX = (amount, ...args) => {
                const response = session.transferSTX(new clarinet_sdk_wasm_1.TransferSTXArgs(BigInt(amount), ...args));
                return parseTxResponse(response);
            };
            return callTransferSTX;
        }
        if (prop === "mineBlock") {
            const callMineBlock = (txs) => {
                const serializedTxs = txs.map((tx) => {
                    if (tx.callPublicFn) {
                        return {
                            callPublicFn: {
                                ...tx.callPublicFn,
                                args_maps: tx.callPublicFn.args.map((a) => transactions_1.Cl.serialize(a)),
                            },
                        };
                    }
                    return tx;
                });
                const responses = session.mineBlock(serializedTxs);
                return responses.map(parseTxResponse);
            };
            return callMineBlock;
        }
        if (prop === "getDataVar") {
            const getDataVar = (...args) => {
                const response = session.getDataVar(...args);
                const result = transactions_1.Cl.deserialize(response);
                return result;
            };
            return getDataVar;
        }
        if (prop === "getMapEntry") {
            const getMapEntry = (contract, mapName, mapKey) => {
                const response = session.getMapEntry(contract, mapName, transactions_1.Cl.serialize(mapKey));
                const result = transactions_1.Cl.deserialize(response);
                return result;
            };
            return getMapEntry;
        }
        return Reflect.get(session, prop, receiver);
    },
});
// load wasm only once and memoize it
function memoizedInit() {
    let simnet = null;
    return async (manifestPath = "./Clarinet.toml") => {
        if (!simnet) {
            const module = await wasmModule;
            simnet = new Proxy(new module.SDK(vfs_js_1.vfs), getSessionProxy());
        }
        // start a new simnet session
        await simnet.initSession(process.cwd(), manifestPath);
        return simnet;
    };
}
exports.initSimnet = memoizedInit();
//# sourceMappingURL=index.js.map