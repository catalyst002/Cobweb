"use strict";
//  NOTICE
//  Copyright 2015 D2L Corporation
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.joseToDer = exports.derToJose = void 0;
// The following code is adapted from https://github.com/Brightspace/node-ecdsa-sig-formatter
const base64_js_1 = require("base64-js");
const base64Url_1 = require("./base64Url");
function getParamSize(keySize) {
    return ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521),
};
function getParamBytesForAlg(alg) {
    const paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
        return paramBytes;
    }
    throw new Error(`Unknown algorithm "${alg}"`);
}
const MAX_OCTET = 0x80;
const CLASS_UNIVERSAL = 0;
const PRIMITIVE_BIT = 0x20;
const TAG_SEQ = 0x10;
const TAG_INT = 0x02;
const ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6);
const ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);
function signatureAsBytes(signature) {
    if (signature instanceof Uint8Array) {
        return signature;
    }
    else if ('string' === typeof signature) {
        return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));
    }
    throw new TypeError('ECDSA signature must be a Base64 string or a Uint8Array');
}
function derToJose(signature, alg) {
    const signatureBytes = signatureAsBytes(signature);
    const paramBytes = getParamBytesForAlg(alg);
    // the DER encoded param should at most be the param size, plus a padding
    // zero, since due to being a signed integer
    const maxEncodedParamLength = paramBytes + 1;
    const inputLength = signatureBytes.length;
    let offset = 0;
    if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
    }
    let seqLength = signatureBytes[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signatureBytes[offset++];
    }
    if (inputLength - offset < seqLength) {
        throw new Error(`"seq" specified length of "${seqLength}", only "${inputLength - offset}" remaining`);
    }
    if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
    }
    const rLength = signatureBytes[offset++];
    if (inputLength - offset - 2 < rLength) {
        throw new Error(`"r" specified length of "${rLength}", only "${inputLength - offset - 2}" available`);
    }
    if (maxEncodedParamLength < rLength) {
        throw new Error(`"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`);
    }
    const rOffset = offset;
    offset += rLength;
    if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
    }
    const sLength = signatureBytes[offset++];
    if (inputLength - offset !== sLength) {
        throw new Error(`"s" specified length of "${sLength}", expected "${inputLength - offset}"`);
    }
    if (maxEncodedParamLength < sLength) {
        throw new Error(`"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`);
    }
    const sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
        throw new Error(`Expected to consume entire array, but "${inputLength - offset}" bytes remain`);
    }
    const rPadding = paramBytes - rLength;
    const sPadding = paramBytes - sLength;
    const dst = new Uint8Array(rPadding + rLength + sPadding + sLength);
    for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
    }
    dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);
    offset = paramBytes;
    for (const o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
    }
    dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);
    return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));
}
exports.derToJose = derToJose;
function countPadding(buf, start, stop) {
    let padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
    }
    const needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
        --padding;
    }
    return padding;
}
function joseToDer(signature, alg) {
    signature = signatureAsBytes(signature);
    const paramBytes = getParamBytesForAlg(alg);
    const signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
        throw new TypeError(`"${alg}" signatures must be "${paramBytes * 2}" bytes, saw "${signatureBytes}"`);
    }
    const rPadding = countPadding(signature, 0, paramBytes);
    const sPadding = countPadding(signature, paramBytes, signature.length);
    const rLength = paramBytes - rPadding;
    const sLength = paramBytes - sPadding;
    const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    const shortLength = rsBytes < MAX_OCTET;
    const dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);
    let offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
        // Bit 8 has value "0"
        // bits 7-1 give the length.
        dst[offset++] = rsBytes;
    }
    else {
        // Bit 8 of first octet has value "1"
        // bits 7-1 give the number of additional length octets.
        dst[offset++] = MAX_OCTET | 1;
        // length, base 256
        dst[offset++] = rsBytes & 0xff;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(0, paramBytes), offset);
        offset += paramBytes;
    }
    else {
        dst.set(signature.subarray(rPadding, paramBytes), offset);
        offset += paramBytes - rPadding;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(paramBytes), offset);
    }
    else {
        dst.set(signature.subarray(paramBytes + sPadding), offset);
    }
    return dst;
}
exports.joseToDer = joseToDer;
//# sourceMappingURL=ecdsaSigFormatter.js.map