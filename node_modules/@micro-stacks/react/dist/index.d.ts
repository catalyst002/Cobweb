import * as _micro_stacks_client from '@micro-stacks/client';
import { Client, OpenSignStructuredMessageParams, ContractDeployParams, ContractCallParams, StxTransferParams, getClient, ClientConfig } from '@micro-stacks/client';
import { StacksNetwork } from 'micro-stacks/network';
import { SignedOptionsWithOnHandlers, SignatureData, FinishedTxData } from 'micro-stacks/connect';
import * as React from 'react';
import { PropsWithChildren } from 'react';

declare const useMicroStacksClient: () => _micro_stacks_client.MicroStacksClient;
declare const useAppDetails: () => {
    appName: string | undefined;
    appIconUrl: string | undefined;
};

interface UseAuth {
    openAuthRequest: Client['authenticate'];
    signOut: Client['signOut'];
    isSignedIn: boolean;
    isRequestPending: boolean;
}
declare const useAuth: () => UseAuth;

interface UseNetwork {
    network: StacksNetwork;
    isMainnet: boolean;
    setNetwork: (network: 'mainnet' | 'testnet' | StacksNetwork) => void;
}
declare function useNetwork(): UseNetwork;

declare const useWatchAccounts: () => _micro_stacks_client.Account[];
declare const useWatchStxAddress: () => string | undefined;
declare function useAccount(): {
    appPrivateKey: string | null;
    rawAddress: [version: number, hash: string] | undefined;
    identityAddress: string | undefined;
    decentralizedID: string | undefined;
    stxAddress: string | undefined;
    profileUrl: string | undefined;
};
declare function useIsGaiaAvailable(): boolean;

declare const useStatuses: () => {
    "status/Authentication": _micro_stacks_client.Status;
    "status/TransactionSigning": _micro_stacks_client.Status;
    "status/MessageSigning": _micro_stacks_client.Status;
    "status/StructuredMessageSigning": _micro_stacks_client.Status;
};

interface UseOpenSignMessage {
    openSignMessage: (params: SignedOptionsWithOnHandlers<{
        message: string;
    }>) => Promise<SignatureData | undefined>;
    isRequestPending: boolean;
}
declare const useOpenSignMessage: (callbacks?: SignedOptionsWithOnHandlers<{}>) => UseOpenSignMessage;

interface UseOpenSignStructuredMessage {
    openSignStructuredMessage: (params: OpenSignStructuredMessageParams) => Promise<SignatureData | undefined>;
    isRequestPending: boolean;
}
declare const useOpenSignStructuredMessage: (callbacks?: SignedOptionsWithOnHandlers<{}>) => UseOpenSignStructuredMessage;

interface OptionalParams {
    onFinish?: (payload: FinishedTxData) => void;
    onCancel?: (error?: string) => void;
}

interface UseOpenContractDeploy {
    openContractDeploy: (params: ContractDeployParams) => Promise<FinishedTxData | undefined>;
    isRequestPending: boolean;
}
declare const useOpenContractDeploy: (callbacks?: OptionalParams) => UseOpenContractDeploy;

interface UseOpenContractCall {
    openContractCall: (params: ContractCallParams) => Promise<FinishedTxData | undefined>;
    isRequestPending: boolean;
}
declare const useOpenContractCall: (callbacks?: OptionalParams) => UseOpenContractCall;

interface UseOpenStxTokenTransfer {
    openStxTokenTransfer: (params: StxTransferParams) => Promise<FinishedTxData | undefined>;
    isRequestPending: boolean;
}
declare const useOpenStxTokenTransfer: (callbacks?: OptionalParams) => UseOpenStxTokenTransfer;

interface UseGetFileOptions<T> {
    decrypt?: boolean;
    verify?: boolean;
    deserialize?: (value: string | Uint8Array) => T;
}
interface UsePutFileOptions<T> {
    encrypt?: boolean;
    sign?: boolean;
    serialize?: (value: T) => string | Uint8Array;
    onSuccess?: (path: string | null) => void;
    onError?: (error: Error) => void;
}
declare const useGetFile: <T = unknown>(filename: string, options?: UseGetFileOptions<T> | undefined) => {
    data: string | Uint8Array | T | null | undefined;
    isLoading: boolean;
    hasError: boolean;
    error: Error | undefined;
};
declare const usePutFile: <T = unknown>(filename: string, contents: T, options?: UsePutFileOptions<T> | undefined) => {
    data: string | null | undefined;
    isLoading: boolean;
    hasError: boolean;
    error: Error | undefined;
    putFile: () => Promise<string | null>;
};

declare const ClientProvider: React.FC<PropsWithChildren<{
    client?: ReturnType<typeof getClient>;
    enableSessionConsistencyEffect?: boolean;
    enableTabSync?: boolean;
} & ClientConfig>>;

export { ClientProvider, OptionalParams, UseOpenSignMessage, UseOpenSignStructuredMessage, useAccount, useWatchAccounts as useAccountsRaw, useAppDetails, useAuth, useWatchStxAddress as useCurrentStxAddress, useGetFile, useIsGaiaAvailable, useMicroStacksClient, useNetwork, useOpenContractCall, useOpenContractDeploy, useOpenSignMessage, useOpenSignStructuredMessage, useOpenStxTokenTransfer, usePutFile, useStatuses };
