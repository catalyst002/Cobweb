import * as c from 'react';
import { createContext, useContext, useCallback, useMemo, useEffect } from 'react';
import v from 'use-sync-external-store/shim/with-selector.js';
import { createClient, defaultStorage, getAccounts, getStxAddress, getStatus, StatusKeys, Status, TxType, getCurrentAccount, getIdentityAddress, getDecentralizedID, getNetwork } from '@micro-stacks/client';
import { ChainID } from 'micro-stacks/network';
import { useAsync, useAsyncCallback } from 'react-async-hook';
import { getGlobalObject } from 'micro-stacks/common';

var p=createContext(null);var{useSyncExternalStoreWithSelector:U}=v;function C(e){return ()=>{let t=u();return U(t.subscribe,t.getState,t.getState,n=>e({client:t,state:n}))}}var u=()=>{let e=useContext(p);if(!e)throw new Error("No MicroStacksClient set, wrap your app in MicroStacksClientProvider to set one");return e},N=C(e=>e.client.selectAppDetails(e.state??e.client.getState())),Ve=()=>{let e=N();return {appName:e==null?void 0:e.name,appIconUrl:e==null?void 0:e.icon}};var Je=C(getAccounts),z=C(getCurrentAccount),G=C(getIdentityAddress),V=C(getDecentralizedID),_=C(getStxAddress);function M(){let e=z(),t=_(),n=G(),f=V();return {appPrivateKey:(e==null?void 0:e.appPrivateKey)??null,rawAddress:e==null?void 0:e.address,identityAddress:n,decentralizedID:f,stxAddress:t,profileUrl:e==null?void 0:e.profile_url}}function Qe(){return !!M().appPrivateKey}var g=C(getStatus);var rt=()=>{let e=u(),{stxAddress:t}=M(),n=g();return {openAuthRequest:e.authenticate,signOut:e.signOut,isSignedIn:!!t,isRequestPending:n[StatusKeys.Authentication]===Status.IsLoading}};var $=C(getNetwork);function Ct(){let e=u(),t=$();t.isMainnet=useCallback(()=>t.chainId===ChainID.Mainnet,[t.chainId]);let n=useMemo(()=>t.isMainnet(),[t]);return {setNetwork:e.setNetwork,network:t,isMainnet:n}}var ht=e=>{let t=u(),n=g(),f=useCallback(async r=>t.signMessage({message:r.message,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.MessageSigning]===Status.IsLoading,[n]);return {openSignMessage:f,isRequestPending:S}};var Ft=e=>{let t=u(),n=g(),f=useCallback(r=>t.signStructuredMessage({message:r.message,domain:r.domain,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.StructuredMessageSigning]===Status.IsLoading,[n]);return {openSignStructuredMessage:f,isRequestPending:S}};var Ut=e=>{let t=u(),n=g(),f=useCallback(r=>t.signTransaction(TxType.ContractDeploy,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.TransactionSigning]===Status.IsLoading,[n]);return {openContractDeploy:f,isRequestPending:S}};var Kt=e=>{let t=u(),n=g(),f=useCallback(r=>t.signTransaction(TxType.ContractCall,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.TransactionSigning]===Status.IsLoading,[n]);return {openContractCall:f,isRequestPending:S}};var Jt=e=>{let t=u(),n=g(),f=useCallback(r=>t.signTransaction(TxType.TokenTransfer,{...r,onFinish:i=>{var o,s;(o=r==null?void 0:r.onFinish)==null||o.call(r,i),(s=e==null?void 0:e.onFinish)==null||s.call(e,i);},onCancel:i=>{var o,s;(o=r==null?void 0:r.onCancel)==null||o.call(r,i),(s=e==null?void 0:e.onCancel)==null||s.call(e,i);}}),[t,e]),S=useMemo(()=>n[StatusKeys.TransactionSigning]===Status.IsLoading,[n]);return {openStxTokenTransfer:f,isRequestPending:S}};var $t=(e,t)=>{let n=u(),f=useCallback(async()=>{let o=await n.getFile(e,{decrypt:t==null?void 0:t.decrypt,verify:t==null?void 0:t.verify});return o?t!=null&&t.deserialize?t.deserialize(o):o:null},[e,n,t]),{result:S,loading:r,error:i}=useAsync(f,[t]);return {data:S,isLoading:r,hasError:!!i,error:i}},kt=(e,t,n)=>{let f=u(),S=n==null?void 0:n.serialize,r=useCallback(d=>S?S(d):JSON.stringify(d),[S]),i=useCallback(async()=>await f.putFile(e,r(t),{encrypt:n==null?void 0:n.encrypt,sign:n==null?void 0:n.sign})??null,[e,t,f,r,n==null?void 0:n.encrypt,n==null?void 0:n.sign]),{loading:o,result:s,error:x,execute:y}=useAsyncCallback(i,{onSuccess:useCallback(d=>{var m;return (m=n==null?void 0:n.onSuccess)==null?void 0:m.call(n,d)},[n]),onError:useCallback(d=>{var m;return (m=n==null?void 0:n.onError)==null?void 0:m.call(n,d)},[n])});return {data:s,isLoading:o,hasError:!!x,error:x,putFile:useCallback(async()=>y(),[y])}};var Te=(e,t)=>Boolean(getGlobalObject("document"))?c.useLayoutEffect(e,t):void 0,P=e=>{let t=c.useRef(e);return Te(()=>{t.current=e;},[]),c.useCallback((...n)=>t.current(...n),[])};var Fe=()=>u().setOnNoWalletFound,Ae=()=>u().setOnPersistState,Re=()=>u().setOnAuthentication,Ee=()=>u().setOnSignOut,A=e=>{let t=Re(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);},R=e=>{let t=Ee(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);},E=e=>{let t=Ae(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);},D=e=>{let t=Fe(),n=P(e);useEffect(()=>{e&&t(n);},[e,t,n]);};var ve=c.memo(({onPersistState:e,onAuthentication:t,onSignOut:n,onNoWalletFound:f})=>(A(t),R(n),E(e),D(f),null));function Ue(e,t,n){let f=c.useRef(!1);c.useEffect(()=>{n&&(t==null?void 0:t.onPersistState)&&!f.current&&(f.current=!0,!t.dehydratedState&&e.selectHasSession(e.getState())&&e.persist());},[n,e,t==null?void 0:t.onPersistState,t==null?void 0:t.dehydratedState]);}function Ie(e,t=!1){c.useEffect(()=>e.tabSyncSubscription(t),[e,t]);}var Cn=c.memo(({children:e,client:t,enableSessionConsistencyEffect:n=!1,enableTabSync:f=!1,dehydratedState:S,appIconUrl:r,appName:i,network:o,storage:s=defaultStorage,onPersistState:x,onAuthentication:y,onNoWalletFound:d,onSignOut:m,enableNetworkSwitching:T})=>{if(c.useContext(p))throw Error("[@micro-stacks/react] Nested ClientProviders detected, you should only have one instance of this component at the root of your app.");let F=c.useMemo(()=>({appName:i,appIconUrl:r,dehydratedState:S,network:o,enableNetworkSwitching:T,storage:s,onPersistState:x,onAuthentication:y,onNoWalletFound:d,onSignOut:m}),[i,r,S,o,T,s,x,y,d,m]),[l]=c.useState(()=>createClient({config:F,client:t}));return Ue(l,F,n),Ie(l,f),c.createElement(p.Provider,{value:l},c.createElement(c.Fragment,null,t?null:c.createElement(ve,{onPersistState:x,onAuthentication:y,onSignOut:m}),e))});

export { Cn as ClientProvider, M as useAccount, Je as useAccountsRaw, Ve as useAppDetails, rt as useAuth, _ as useCurrentStxAddress, $t as useGetFile, Qe as useIsGaiaAvailable, u as useMicroStacksClient, Ct as useNetwork, Kt as useOpenContractCall, Ut as useOpenContractDeploy, ht as useOpenSignMessage, Ft as useOpenSignStructuredMessage, Jt as useOpenStxTokenTransfer, kt as usePutFile, g as useStatuses };
