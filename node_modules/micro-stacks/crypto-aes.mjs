import { concatByteArrays } from 'micro-stacks/common';

var a=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var y=class{webCrypto;constructor(r){this.webCrypto=r;}async encrypt(r,t,i,n){let o,p;if(r==="aes-128-cbc")o="AES-CBC",p=128;else if(r==="aes-256-cbc")o="AES-CBC",p=256;else throw new Error(`Unsupported cipher algorithm "${r}"`);let C=await this.webCrypto.subtle.importKey("raw",t,{name:o,length:p},!1,["encrypt"]),l=await this.webCrypto.subtle.encrypt({name:o,iv:i},C,n);return new Uint8Array(l)}async decrypt(r,t,i,n){let o,p;if(r==="aes-128-cbc")o="AES-CBC",p=128;else if(r==="aes-256-cbc")o="AES-CBC",p=256;else throw new Error(`Unsupported cipher algorithm "${r}"`);let C=await this.webCrypto.subtle.importKey("raw",t,{name:o,length:p},!1,["decrypt"]),l=await this.webCrypto.subtle.decrypt({name:o,iv:i},C,n);return new Uint8Array(l)}};var s=class{createCipher;createDecipher;constructor(r,t){this.createCipher=r,this.createDecipher=t;}async encrypt(r,t,i,n){if(r!=="aes-128-cbc"&&r!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${r}"`);let o=this.createCipher(r,t,i),p=concatByteArrays([o.update(n),o.final()]);return Promise.resolve(p)}async decrypt(r,t,i,n){if(r!=="aes-128-cbc"&&r!=="aes-256-cbc")throw new Error(`Unsupported cipher algorithm "${r}"`);let o=this.createDecipher(r,t,i),p=concatByteArrays([o.update(n),o.final()]);return Promise.resolve(p)}};function b(){return typeof crypto<"u"&&typeof crypto.subtle<"u"}function w(e){try{if(!a.resolve("crypto"))return !1;let t=a("crypto");return t?e?e(t):!0:!1}catch{return !1}}var f='Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';async function u(){if(b())return {lib:crypto,name:"webCrypto"};try{return {lib:a("crypto"),name:"nodeCrypto"}}catch{throw new Error(f)}}async function c(){let e=await u();return e.name==="webCrypto"?new y(e.lib):new s(e.lib.createCipheriv,e.lib.createDecipheriv)}async function g(e,r,t){return (await c()).encrypt("aes-256-cbc",r,e,t)}async function B(e,r,t){return (await c()).decrypt("aes-256-cbc",r,e,t)}async function L(e,r,t){return (await c()).encrypt("aes-128-cbc",r,e,t)}async function T(e,r,t){return (await c()).decrypt("aes-128-cbc",r,e,t)}

export { f as NO_CRYPTO_LIB, T as aes128CbcDecrypt, L as aes128CbcEncrypt, B as aes256CbcDecrypt, g as aes256CbcEncrypt, u as getCryptoLib, w as isNodeCryptoAvailable, b as isSubtleCryptoAvailable };
