import * as crypto from 'crypto';
export { getPublicKey } from '@noble/secp256k1';

declare type NodeCryptoCreateHash = typeof crypto.createHash;
declare type NodeCryptoCreateHmac = typeof crypto.createHmac;
interface Sha2Hash {
    digest(data: Uint8Array, algorithm?: 'sha256' | 'sha512'): Promise<Uint8Array>;
}
interface Hmac {
    digest(key: Uint8Array, data: Uint8Array): Promise<Uint8Array>;
}
interface EncryptECIESOptions {
    publicKey: string;
    content: Uint8Array;
    wasString: boolean;
    cipherTextEncoding?: CipherTextEncoding;
}
interface DecryptECIESOptions {
    privateKey: string;
    cipherObject: CipherObject;
}
declare type CipherTextEncoding = 'hex' | 'base64';
declare type CipherObject = {
    iv: string;
    ephemeralPK: string;
    cipherText: string;
    cipherTextEncoding?: CipherTextEncoding;
    mac: string;
    wasString: boolean;
};
declare type SignedCipherObject = {
    signature: string;
    publicKey: string;
    cipherText: string;
};
interface EncryptionOptions {
    sign?: boolean | string;
    cipherTextEncoding?: CipherTextEncoding;
    wasString?: boolean;
}
interface EncryptContentOptions extends EncryptionOptions {
    publicKey?: string;
    privateKey?: string;
}

declare function getAesCbcOutputLength(inputByteLength: number): number;
declare function getBase64OutputLength(inputByteLength: number): number;
declare function getCipherObjectWrapper(opts: {
    wasString: boolean;
    cipherTextEncoding: CipherTextEncoding;
}): {
    payloadShell: string;
    payloadValuesLength: number;
};
declare function getSignedCipherObjectWrapper(payloadShell: string): {
    signedPayloadValuesLength: number;
    signedPayloadShell: string;
};
declare function eciesGetJsonStringLength(opts: {
    contentLength: number;
    wasString: boolean;
    sign: boolean;
    cipherTextEncoding: CipherTextEncoding;
}): number;

interface Ripemd160Digest {
    digest(data: Uint8Array): Uint8Array;
}
declare class Ripemd160PolyfillDigest implements Ripemd160Digest {
    digest(data: Uint8Array): Uint8Array;
}
declare function createHashRipemd160(): Ripemd160PolyfillDigest;
declare function hashRipemd160(data: Uint8Array): Uint8Array;

declare function ripemd160(message: Uint8Array): Uint8Array;
declare function ripemd160(message: string): string;

declare function sharedSecretToKeys(sharedSecret: Uint8Array): {
    encryptionKey: Uint8Array;
    hmacKey: Uint8Array;
};

declare function getRandomBytes(size?: number): Uint8Array;

declare const isCompressedPublicKey: (bytes: Uint8Array) => boolean;
declare const derivePublicKey: (pubKey: Uint8Array, il: Uint8Array) => Uint8Array;
declare const derivePrivateKey: (privateKey: Uint8Array, il: Uint8Array) => Uint8Array;

declare enum StacksNetworkVersion {
    mainnetP2PKH = 22,
    mainnetP2SH = 20,
    testnetP2PKH = 26,
    testnetP2SH = 21
}
declare const BITCOIN_TO_STACKS_NETWORK_VERSION: Record<number, number>;
declare const STACKS_TO_BITCOIN_NETWORK_VERSION: Record<number, number>;
declare function c32address(version: StacksNetworkVersion, hash160: Uint8Array): string;
declare function b58ToC32(b58check: string): string;
declare function c32ToB58(c32string: string): string;
declare function c32addressDecode(c32addr: string): [number, Uint8Array];
declare function c32checkDecode(c32data: string): [number, Uint8Array];
declare function c32normalize(c32input: string): string;
declare function c32decode(c32input: string): Uint8Array;
declare function validateStacksAddress(stacksAddress: string): boolean;

declare enum BitcoinNetworkVersion {
    mainnetP2PKH = 0,
    mainnetP2SH = 5,
    testnetP2PKH = 111,
    testnetP2SH = 196
}

declare function base58checkEncode(hash: Uint8Array, version: BitcoinNetworkVersion): string;
declare function base58checkDecode(address: string): {
    hash: Uint8Array;
    version: number;
};

declare function privateKeyToStxAddress(privateKey: string | Uint8Array, addressVersion?: StacksNetworkVersion, isCompressed?: boolean): string;
declare function publicKeyToStxAddress(publicKey: string | Uint8Array, addressVersion?: StacksNetworkVersion): string;
declare function privateKeyToBase58Address(privateKey: string): string;
declare function publicKeyToBase58Address(publicKey: string | Uint8Array): string;
declare const hashP2PKH: (input: Uint8Array) => string;
declare const hashP2WPKH: (input: Uint8Array) => string;
declare const hashP2WSH: (numSigs: number, pubKeys: Uint8Array[]) => string;
declare const hashP2SH: (numSigs: number, pubKeys: Uint8Array[]) => string;

interface SignECDSA {
    privateKey: string;
    contents: string | ArrayBuffer | Uint8Array;
}
interface SignedResponse {
    signature: string;
    publicKey: string;
}
declare function signECDSA(params: SignECDSA): Promise<SignedResponse>;
interface VerifyESDSA {
    contents: string | ArrayBuffer | Uint8Array;
    publicKey: string;
    signature: string;
}
declare function verifyECDSA(params: VerifyESDSA, strict?: boolean): boolean;

declare function encryptECIES(options: EncryptECIESOptions): Promise<CipherObject>;

declare function equalConstTime(b1: Uint8Array, b2: Uint8Array): boolean;
declare function decryptECIES(options: DecryptECIESOptions): Promise<Uint8Array | string>;

declare function decryptContent(content: string, options: {
    privateKey: string;
}): Promise<string | Uint8Array>;

declare function encryptContent(content: string | Uint8Array, options: EncryptContentOptions): Promise<string>;

declare type Json = string | number | boolean | null | Json[] | {
    [key: string]: Json;
};
interface JSONObject {
    [key: string]: Json;
}
interface TokenInterface {
    header: {
        [key: string]: string | Json;
        alg?: any;
        typ?: any;
    };
    payload: {
        [key: string]: Json;
        iss?: any | string;
        jti?: any | string;
        iat?: any | string | number;
        exp?: any | string | number;
    } | string;
    signature: string;
}
interface TokenInterfaceEncodedObject {
    header: string[];
    payload: string;
    signature: string;
}
interface SignedToken {
    header: string[];
    payload: string;
    signature: string[];
}

declare class TokenSigner {
    tokenType: string;
    rawPrivateKey: string;
    constructor(_signingAlgorithm: string | undefined, rawPrivateKey: string);
    header(header?: {}): {
        typ: string;
        alg: string;
    };
    sign(payload: Json): Promise<string>;
    sign(payload: Json, expanded: true, customHeader?: Json): Promise<SignedToken>;
    sign(payload: Json, expanded: false, customHeader?: Json): Promise<string>;
    signSync(payload: Json): string;
    signSync(payload: Json, expanded: true, customHeader?: Json): SignedToken;
    signSync(payload: Json, expanded: false, customHeader?: Json): string;
    createWithSignedHash(payload: Json, expanded: boolean, header: {
        typ: string;
        alg: string;
    }, signingInput: string, signingInputHash: Uint8Array): Promise<SignedToken | string>;
    createWithSignedHashSync(payload: Json, expanded: boolean, header: {
        typ: string;
        alg: string;
    }, signingInput: string, signingInputHash: Uint8Array): SignedToken | string;
}

declare class TokenVerifier {
    tokenType: string;
    rawPublicKey: string;
    constructor(_signingAlgorithm: string, rawPublicKey: string);
    verify(token: string | SignedToken, strict?: boolean): boolean;
    verifyCompact(token: string, strict?: boolean): boolean;
    verifyExpanded(token: SignedToken, strict?: boolean): boolean;
}

declare function decodeToken(token: string | TokenInterface | TokenInterfaceEncodedObject): TokenInterface | undefined;

declare function createSigningInput(payload: Json, header: Json): string;

declare function createUnsecuredToken(payload: Json): string;

export { BITCOIN_TO_STACKS_NETWORK_VERSION, CipherObject, CipherTextEncoding, DecryptECIESOptions, EncryptContentOptions, EncryptECIESOptions, EncryptionOptions, Hmac, JSONObject, Json, NodeCryptoCreateHash, NodeCryptoCreateHmac, Ripemd160Digest, Ripemd160PolyfillDigest, STACKS_TO_BITCOIN_NETWORK_VERSION, Sha2Hash, SignedCipherObject, SignedToken, StacksNetworkVersion, TokenInterface, TokenSigner, TokenVerifier, b58ToC32, base58checkDecode, base58checkEncode, c32ToB58, c32address, c32addressDecode, c32checkDecode, c32decode, c32normalize, createHashRipemd160, createSigningInput, createUnsecuredToken, decodeToken, decryptContent, decryptECIES, derivePrivateKey, derivePublicKey, eciesGetJsonStringLength, encryptContent, encryptECIES, equalConstTime, getAesCbcOutputLength, getBase64OutputLength, getCipherObjectWrapper, getRandomBytes, getSignedCipherObjectWrapper, hashP2PKH, hashP2SH, hashP2WPKH, hashP2WSH, hashRipemd160, isCompressedPublicKey, privateKeyToBase58Address, privateKeyToStxAddress, publicKeyToBase58Address, publicKeyToStxAddress, ripemd160, sharedSecretToKeys, signECDSA, validateStacksAddress, verifyECDSA };
