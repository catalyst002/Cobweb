declare function arrayBufferToUint8(content: ArrayBuffer): Uint8Array;
interface GetGlobalObjectOptions {
    throwIfUnavailable?: boolean;
    usageDesc?: string;
    returnEmptyObject?: boolean;
}
declare function getGlobalObject<K extends Extract<keyof Window, string>>(name: K, { throwIfUnavailable, usageDesc, returnEmptyObject }?: GetGlobalObjectOptions): Window[K] | undefined;
declare function concatByteArrays(byteArrays: Uint8Array[]): Uint8Array;
declare function ensureUint8Array(bytes: Uint8Array): Uint8Array;

declare type IntegerType = number | string | bigint | Uint8Array;
declare function intToBytes(value: IntegerType, signed?: boolean, byteOffset?: number): Uint8Array;
declare function intToHex(value: IntegerType, signed?: boolean, byteOffset?: number): string;
declare function intToBigInt(value: IntegerType, signed?: boolean): bigint;
declare const bytesToBigInt: (bytes: Uint8Array) => bigint;

declare class StacksTransactionError extends Error {
    constructor(message: string);
}
declare class SerializationError extends Error {
    constructor(message: string);
}
declare class DeserializationError extends Error {
    constructor(message: string);
}
declare class NotImplementedError extends Error {
    constructor(message: string);
}
declare class SigningError extends Error {
    constructor(message: string);
}
declare class VerificationError extends Error {
    constructor(message: string);
}
declare class MissingParametersError extends Error {
    constructor(message: string);
}
declare class InvalidTokenError extends Error {
    constructor(message: string);
}

declare function cloneDeep<T>(value: T): T;
declare function omit<T, K extends keyof T>(obj: T, prop: K): Omit<T, K>;

declare function fetchPrivate(input: RequestInfo, init?: RequestInit): Promise<Response>;

declare function byteLength(b64: string): number;
declare function base64ToBytesBase(b64: string, code: string): Uint8Array;
declare function base64ToBytes(b64: string): Uint8Array;
declare function base64UrlToBytes(b64: string): Uint8Array;
declare function bytesToBase64Base(uint8: Uint8Array, code: string): string;
declare function bytesToBase64(uint8: Uint8Array): string;
declare function bytesToBase64Url(uint8: Uint8Array): string;

/*! micro-base58 - MIT License (c) 2021, Paul Miller (https://paulmillr.com) */
declare function encodeB58(source: string | Uint8Array): string;
declare function decodeB58(output: string): Uint8Array;

declare function hexToBytes(hex: string): Uint8Array;
declare function bytesToHex(uint8a: Uint8Array): string;
declare function numberToHex(num: number | bigint): string;
declare function hexToBigInt(hex: string): bigint;
declare const intToHexString: (integer: IntegerType, lengthBytes?: number) => string;
declare const hexStringToInt: (hexString: string) => number;
declare const hexToJSON: (hex: string) => any;
declare const ensureHexBytes: (bytesOrHex: string | Uint8Array) => Uint8Array;
declare const cleanHex: (hexMaybePrefixed: string) => string;

declare function asciiToBytes(str: string): Uint8Array;
declare function bytesToAscii(buffer: Uint8Array): string;

declare function utf8ToBytes(content: string): Uint8Array;
declare function bytesToUtf8(buffer: Uint8Array): string;

declare function copy(currentBuff: Uint8Array, target: Uint8Array, targetStart: number, start?: number, end?: number): number;

declare class BufferArray {
    _value: Uint8Array[];
    get value(): Uint8Array[];
    appendHexString(hexString: string): void;
    push(buffer: Uint8Array): number;
    appendByte(octet: number): void;
    concatBuffer(): Uint8Array;
}

declare class BufferReader {
    buffer: Uint8Array;
    view: DataView;
    _readOffset: number;
    constructor(buff?: Uint8Array);
    private ensureReadable;
    private _readNumberValue;
    readBuffer(length?: number): Uint8Array;
    readUInt32BE(offset?: number): number;
    readUInt8(offset?: number): number;
    readUInt16BE(offset?: number): number;
    readBigUIntLE(length: number): BigInt;
    readBigUIntBE(length: number): BigInt;
    readBigUInt64BE(offset?: number): bigint;
    get readOffset(): number;
    set readOffset(val: number);
    get internalBuffer(): ArrayBuffer;
    readUInt8Enum<T extends string, TEnumValue extends number>(enumVariable: {
        [key in T]: TEnumValue;
    }, invalidEnumErrorFormatter: (val: number) => Error): TEnumValue;
}

declare function writeUInt8(buffer: Uint8Array, value: number, offset: number): number;
declare function writeUInt16LE(buffer: Uint8Array, value: number, offset: number): number;
declare function writeUInt16BE(buffer: Uint8Array, value: number, offset: number): number;
declare function readUInt8(buffer: Uint8Array, offset: number): number;
declare function readUInt16LE(buffer: Uint8Array, offset: number): number;
declare function readInt32LE(buffer: Uint8Array, offset: number): number;
declare function readUInt32LE(buffer: Uint8Array, offset: number): number;
declare function readUInt32BE(buffer: Uint8Array, offset: number): number;
declare function writeUInt32LE(buffer: Uint8Array, value: number, offset: number): number;
declare function writeInt32LE(buffer: Uint8Array, value: number, offset: number): number;
declare function writeUInt32BE(buffer: Uint8Array, value: number, offset: number): number;
declare function compare(a: Uint8Array, b: Uint8Array): 1 | 0 | -1;
declare function readBuffer(buffer: Uint8Array, length?: number): Uint8Array;
declare function isEnum<T extends string, TEnumValue extends number>(enumVariable: {
    [key in T]: TEnumValue;
}, value: number): value is TEnumValue;
declare function isInteger(value: number): boolean;
declare function isFiniteInteger(value: number): boolean;
declare function checkOffsetOrLengthValue(value: any, offset: boolean): void;

declare const ERRORS: {
    readonly INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.";
    readonly INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.";
    readonly INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.";
    readonly INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.";
    readonly INVALID_OFFSET: "An invalid offset value was provided.";
    readonly INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.";
    readonly INVALID_LENGTH: "An invalid length value was provided.";
    readonly INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.";
    readonly INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.";
    readonly INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.";
    readonly INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.";
    readonly INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data.";
};

declare function toTwos(value: bigint, bitlength?: string | number): bigint;
declare function fromTwos(value: bigint, bitlength?: string | number): bigint;

declare enum ChainID {
    Testnet = 2147483648,
    Mainnet = 1
}
declare const DEFAULT_CHAIN_ID = ChainID.Mainnet;
declare enum TransactionVersion {
    Mainnet = 0,
    Testnet = 128
}

export { BufferArray, BufferReader, ChainID, DEFAULT_CHAIN_ID, DeserializationError, ERRORS, IntegerType, InvalidTokenError, MissingParametersError, NotImplementedError, SerializationError, SigningError, StacksTransactionError, TransactionVersion, VerificationError, arrayBufferToUint8, asciiToBytes, base64ToBytes, base64ToBytesBase, base64UrlToBytes, byteLength, bytesToAscii, bytesToBase64, bytesToBase64Base, bytesToBase64Url, bytesToBigInt, bytesToHex, bytesToUtf8, checkOffsetOrLengthValue, cleanHex, cloneDeep, compare, concatByteArrays, copy, decodeB58, encodeB58, ensureHexBytes, ensureUint8Array, fetchPrivate, fromTwos, getGlobalObject, hexStringToInt, hexToBigInt, hexToBytes, hexToJSON, intToBigInt, intToBytes, intToHex, intToHexString, isEnum, isFiniteInteger, isInteger, numberToHex, omit, readBuffer, readInt32LE, readUInt16LE, readUInt32BE, readUInt32LE, readUInt8, toTwos, utf8ToBytes, writeInt32LE, writeUInt16BE, writeUInt16LE, writeUInt32BE, writeUInt32LE, writeUInt8 };
