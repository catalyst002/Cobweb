import { TransactionVersion, bytesToHex, hexToBytes, hexToBigInt, BufferArray, concatByteArrays, intToHex, intToHexString, hexStringToInt, intToBigInt, intToBytes, DeserializationError, utf8ToBytes, bytesToUtf8, writeUInt16BE, SigningError, BufferReader, NotImplementedError, cloneDeep, fetchPrivate, omit, writeUInt32BE, DEFAULT_CHAIN_ID, SerializationError } from 'micro-stacks/common';
import { hashSha512_256 } from 'micro-stacks/crypto-sha';
import { hexToCV, StacksMessageType, createAddress, createLPString, serializeAddress, PostConditionPrincipalID, serializeLPString, serializeCV, deserializeAddress, deserializeLPString, deserializeCV, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, exceedsMaxLengthBytes, MEMO_MAX_LENGTH_BYTES, ClarityAbiTypeId, stringUtf8CV, stringAsciiCV, bufferCV, noneCV, contractPrincipalCV, standardPrincipalCV, falseCV, trueCV, intCV, uintCV, getCVTypeString, bufferCVFromString, principalCV, COMPRESSED_PUBKEY_LENGTH_BYTES, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, COINBASE_BUFFER_LENGTH_BYTES, ClarityType } from 'micro-stacks/clarity';
import { Signature, Point, getPublicKey, utils, sign } from '@noble/secp256k1';
import { StacksNetworkVersion, hashP2WSH, hashP2SH, hashP2WPKH, hashP2PKH, publicKeyToStxAddress, c32address } from 'micro-stacks/crypto';
import { StacksMainnet, StacksTestnet } from 'micro-stacks/network';
export { callReadOnlyFunction } from 'micro-stacks/api';

var Ki=16,Ei="https://stacks-node-api.mainnet.stacks.co",$e=(r=>(r[r.OnChainOnly=1]="OnChainOnly",r[r.OffChainOnly=2]="OffChainOnly",r[r.Any=3]="Any",r))($e||{}),zi=TransactionVersion.Mainnet,ve=(n=>(n[n.Allow=1]="Allow",n[n.Deny=2]="Deny",n))(ve||{}),Ve=(r=>(r[r.STX=0]="STX",r[r.Fungible=1]="Fungible",r[r.NonFungible=2]="NonFungible",r))(Ve||{}),le=(n=>(n[n.Standard=4]="Standard",n[n.Sponsored=5]="Sponsored",n))(le||{}),De=(i=>(i[i.SerializeP2PKH=0]="SerializeP2PKH",i[i.SerializeP2SH=1]="SerializeP2SH",i[i.SerializeP2WPKH=2]="SerializeP2WPKH",i[i.SerializeP2WSH=3]="SerializeP2WSH",i))(De||{}),Nn=(i=>(i[i.MainnetSingleSig=22]="MainnetSingleSig",i[i.MainnetMultiSig=20]="MainnetMultiSig",i[i.TestnetSingleSig=26]="TestnetSingleSig",i[i.TestnetMultiSig=21]="TestnetMultiSig",i))(Nn||{}),ye=(n=>(n[n.Compressed=0]="Compressed",n[n.Uncompressed=1]="Uncompressed",n))(ye||{}),ge=(o=>(o[o.Equal=1]="Equal",o[o.Greater=2]="Greater",o[o.GreaterEqual=3]="GreaterEqual",o[o.Less=4]="Less",o[o.LessEqual=5]="LessEqual",o))(ge||{}),_e=(n=>(n[n.DoesNotOwn=16]="DoesNotOwn",n[n.Owns=17]="Owns",n))(_e||{}),Hn=(r=>(r[r.STX=0]="STX",r[r.Fungible=1]="Fungible",r[r.NonFungible=2]="NonFungible",r))(Hn||{}),On=(y=>(y.Serialization="Serialization",y.Deserialization="Deserialization",y.SignatureValidation="SignatureValidation",y.FeeTooLow="FeeTooLow",y.BadNonce="BadNonce",y.NotEnoughFunds="NotEnoughFunds",y.NoSuchContract="NoSuchContract",y.NoSuchPublicFunction="NoSuchPublicFunction",y.BadFunctionArgument="BadFunctionArgument",y.ContractAlreadyExists="ContractAlreadyExists",y.PoisonMicroblocksDoNotConflict="PoisonMicroblocksDoNotConflict",y.PoisonMicroblockHasUnknownPubKeyHash="PoisonMicroblockHasUnknownPubKeyHash",y.PoisonMicroblockIsInvalid="PoisonMicroblockIsInvalid",y.BadAddressVersionByte="BadAddressVersionByte",y.NoCoinbaseViaMempool="NoCoinbaseViaMempool",y.ServerFailureNoSuchChainTip="ServerFailureNoSuchChainTip",y.ServerFailureDatabase="ServerFailureDatabase",y.ServerFailureOther="ServerFailureOther",y))(On||{});var wt=e=>e.length%2==0?e:`0${e}`,We=(e,t)=>e.padStart(t,"0"),kt=(e,t)=>e.padEnd(t,"0"),X=e=>{let t=hashSha512_256(e);return bytesToHex(t)};function Li(e){if(e.okay)return hexToCV(e.result);throw new Error(e.cause)}function N(e){return {type:StacksMessageType.PublicKey,data:hexToBytes(e)}}function zt(e,t,n=0,r="vrs"){let i=Jn(t.data,r),o=new Signature(hexToBigInt(i.r),hexToBigInt(i.s)),s=Point.fromSignature(e,o,i.recoveryParam),a=n===0;return s.toHex(a)}function R(e){return {type:StacksMessageType.PublicKey,data:e}}function C(e){return bytesToHex(e.data)}function k(e){return !C(e).startsWith("04")}function qe(e){let t=typeof e=="string"?hexToBytes(e):e,n=!1;if(t.length===33){if(t[t.length-1]!==1)throw new Error("Improperly formatted private-key. 33 byte length usually indicates compressed key, but last byte must be == 0x01");n=!0;}return n}function H(e){let t=new BufferArray;return t.push(e.data),t.concatBuffer()}function O(e){let t=S(e),n=qe(e),r=getPublicKey(t.data.slice(0,32),n||t.compressed);return N(bytesToHex(r))}function Ft(e){let t=typeof e=="string"?e:bytesToHex(e),n=Point.fromHex(t).toHex(!0);return N(n)}function $(e){let t=e.readUInt8(),n=t!==4?COMPRESSED_PUBKEY_LENGTH_BYTES:UNCOMPRESSED_PUBKEY_LENGTH_BYTES;return R(concatByteArrays([Uint8Array.from([t]),e.readBuffer(n)]))}function S(e){let t=typeof e=="string"?hexToBytes(e):e,n;if(t.length===33){if(t[t.length-1]!==1)throw new Error("Improperly formatted private-key. 33 byte length usually indicates compressed key, but last byte must be == 0x01");n=!0;}else if(t.length===32)n=!1;else throw new Error(`Improperly formatted private-key hex string: length should be 32 or 33 bytes, provided with length ${t.length}`);return {data:t,compressed:n}}function qi(){return S(utils.randomPrivateKey())}async function Ut(e,t){let[n,r]=await sign(t,e.data.slice(0,32),{canonical:!0,recovered:!0}),i=Signature.fromHex(n),o=32,s=We(intToHex(i.r),o*2),a=We(intToHex(i.s),o*2);if(r==null)throw new Error('"signature.recoveryParam" is not set');let p=intToHexString(r,1)+s+a;return v(p)}function Gi(e){if(e.length<32*2*2+1)throw new Error("Invalid signature");let n=e.substr(0,2);return hexStringToInt(n)}function Jn(e,t="vrs"){if(e.length<32*2*2+1)throw new Error("Invalid signature");if(t==="vrs"){let s=e.substr(0,2),a=e.substr(2,32*2),c=e.substr(2+32*2,32*2);return {recoveryParam:hexStringToInt(s),r:a,s:c}}let r=e.substr(0,32*2),i=e.substr(32*2,32*2),o=e.substr(32*2*2,2);return {r,s:i,recoveryParam:hexStringToInt(o)}}function I(e){return O(e.data)}function Ji(e){return bytesToHex(e.data)}var h=(o=>(o[o.TokenTransfer=0]="TokenTransfer",o[o.SmartContract=1]="SmartContract",o[o.ContractCall=2]="ContractCall",o[o.PoisonMicroblock=3]="PoisonMicroblock",o[o.Coinbase=4]="Coinbase",o))(h||{});function Ze(e,t,n){return typeof e=="string"&&(e=principalCV(e)),typeof n=="string"&&(n=Ye(n)),{type:StacksMessageType.Payload,payloadType:0,recipient:e,amount:intToBigInt(t,!1),memo:n??Ye("")}}function Qe(e,t,n,r){return typeof e=="string"&&(e=createAddress(e)),typeof t=="string"&&(t=createLPString(t)),typeof n=="string"&&(n=createLPString(n)),{type:StacksMessageType.Payload,payloadType:2,contractAddress:e,contractName:t,functionName:n,functionArgs:r}}function je(e,t){return typeof e=="string"&&(e=createLPString(e)),typeof t=="string"&&(t=Lt(t)),{type:StacksMessageType.Payload,payloadType:1,contractName:e,codeBody:t}}function nr(){return {type:StacksMessageType.Payload,payloadType:3}}function rr(e){if(e.byteLength!=COINBASE_BUFFER_LENGTH_BYTES)throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);return {type:StacksMessageType.Payload,payloadType:4,coinbaseBuffer:e}}function Se(e){let t=new BufferArray;switch(t.appendByte(e.payloadType),e.payloadType){case 0:t.push(serializeCV(e.recipient)),t.push(intToBytes(e.amount,!1,8)),t.push(K(e.memo));break;case 2:t.push(K(e.contractAddress)),t.push(K(e.contractName)),t.push(K(e.functionName));let n=new Uint8Array(4);writeUInt32BE(n,e.functionArgs.length,0),t.push(n),e.functionArgs.forEach(r=>{t.push(serializeCV(r));});break;case 1:t.push(K(e.contractName)),t.push(K(e.codeBody));break;case 3:break;case 4:t.push(e.coinbaseBuffer);break}return t.concatBuffer()}function me(e){switch(e.readUInt8Enum(h,n=>{throw new Error(`Cannot recognize PayloadType: ${n}`)})){case 0:let n=deserializeCV(e),r=intToBigInt(e.readBuffer(8),!1),i=Ce(e);return Ze(n,r,i);case 2:let o=deserializeAddress(e),s=deserializeLPString(e),a=deserializeLPString(e),c=[],p=e.readUInt32BE();for(let ue=0;ue<p;ue++){let Le=deserializeCV(e);c.push(Le);}return Qe(o,s,a,c);case 1:let l=deserializeLPString(e),g=deserializeLPString(e,4,1e5);return je(l,g);case 3:return nr();case 4:let P=e.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);return rr(P)}}function Pe(e,t,n){return typeof e=="string"&&(e=we(e)),{type:StacksMessageType.PostCondition,conditionType:0,principal:e,conditionCode:t,amount:intToBigInt(n,!1)}}function be(e,t,n,r){return typeof e=="string"&&(e=we(e)),typeof r=="string"&&(r=rt(r)),{type:StacksMessageType.PostCondition,conditionType:1,principal:e,conditionCode:t,amount:intToBigInt(n,!1),assetInfo:r}}function xe(e,t,n,r){return typeof e=="string"&&(e=we(e)),typeof n=="string"&&(n=rt(n)),{type:StacksMessageType.PostCondition,conditionType:2,principal:e,conditionCode:t,assetInfo:n,assetName:r}}function et(e){let t=new BufferArray;return t.appendByte(e.conditionType),t.push(tt(e.principal)),(e.conditionType===1||e.conditionType===2)&&t.push(it(e.assetInfo)),e.conditionType===2&&t.push(serializeCV(e.assetName)),t.appendByte(e.conditionCode),(e.conditionType===0||e.conditionType===1)&&t.push(intToBytes(e.amount,!1,8)),t.concatBuffer()}function Ae(e){let t=e.readUInt8Enum(Ve,s=>{throw new DeserializationError(`Could not read ${s} as PostConditionType`)}),n=nt(e),r,i,o;switch(t){case 0:return r=e.readUInt8Enum(ge,a=>{throw new DeserializationError(`Could not read ${a} as FungibleConditionCode`)}),o=BigInt("0x"+bytesToHex(e.readBuffer(8))),{type:StacksMessageType.PostCondition,conditionType:0,principal:n,conditionCode:r,amount:o};case 1:return i=G(e),r=e.readUInt8Enum(ge,a=>{throw new DeserializationError(`Could not read ${a} as FungibleConditionCode`)}),o=BigInt("0x"+bytesToHex(e.readBuffer(8))),{type:StacksMessageType.PostCondition,conditionType:1,principal:n,conditionCode:r,amount:o,assetInfo:i};case 2:i=G(e);let s=deserializeCV(e);return r=e.readUInt8Enum(_e,a=>{throw new DeserializationError(`Could not read ${a} as FungibleConditionCode`)}),{type:StacksMessageType.PostCondition,conditionType:2,principal:n,conditionCode:r,assetInfo:i,assetName:s}}}function K(e){switch(e.type){case StacksMessageType.Address:return serializeAddress(e);case StacksMessageType.Principal:return tt(e);case StacksMessageType.LengthPrefixedString:return serializeLPString(e);case StacksMessageType.MemoString:return Cr(e);case StacksMessageType.AssetInfo:return it(e);case StacksMessageType.PostCondition:return et(e);case StacksMessageType.PublicKey:return H(e);case StacksMessageType.LengthPrefixedList:return ne(e);case StacksMessageType.Payload:return Se(e);case StacksMessageType.TransactionAuthField:return Wt(e);case StacksMessageType.MessageSignature:return ze(e)}}function $o(e,t,n){switch(t){case StacksMessageType.Address:return deserializeAddress(e);case StacksMessageType.Principal:return nt(e);case StacksMessageType.LengthPrefixedString:return deserializeLPString(e);case StacksMessageType.MemoString:return Ce(e);case StacksMessageType.AssetInfo:return G(e);case StacksMessageType.PostCondition:return Ae(e);case StacksMessageType.PublicKey:return $(e);case StacksMessageType.Payload:return me(e);case StacksMessageType.LengthPrefixedList:if(!n)throw new DeserializationError("No List Type specified");return re(e,n);case StacksMessageType.MessageSignature:return ie(e);default:throw new Error("Could not recognize StacksMessageType")}}function _t(){return {type:StacksMessageType.Address,version:StacksNetworkVersion.mainnetP2PKH,hash160:"0".repeat(40)}}function Y(e,t){return {type:StacksMessageType.Address,version:e,hash160:t}}function mr(e,t){switch(e){case 0:switch(t){case TransactionVersion.Mainnet:return StacksNetworkVersion.mainnetP2PKH;case TransactionVersion.Testnet:return StacksNetworkVersion.testnetP2PKH;default:throw new Error(`Unexpected txVersion ${JSON.stringify(t)} for hashMode ${e}`)}case 1:case 2:case 3:switch(t){case TransactionVersion.Mainnet:return StacksNetworkVersion.mainnetP2SH;case TransactionVersion.Testnet:return StacksNetworkVersion.testnetP2SH;default:throw new Error(`Unexpected txVersion ${JSON.stringify(t)} for hashMode ${e}`)}default:throw new Error(`Unexpected hashMode ${JSON.stringify(e)}`)}}function vo(e,t,n){let r=mr(e,t);return Y(r,n)}function j(e,t,n,r){if(r.length===0)throw Error("Invalid number of public keys");if((t===0||t===2)&&(r.length!==1||n!==1))throw Error("Invalid number of public keys or signatures");if(t===2||t===3){for(let i=0;i<r.length;i++)if(!k(r[i]))throw Error("Public keys must be compressed for segwit")}switch(t){case 0:return Y(e,hashP2PKH(r[0].data));case 2:return Y(e,hashP2WPKH(r[0].data));case 1:return Y(e,hashP2SH(n,r.map(H)));case 3:return Y(e,hashP2WSH(n,r.map(H)))}}function we(e){if(e.includes(".")){let[t,n]=e.split(".");return te(t,n)}else return ee(e)}function ee(e){return {type:StacksMessageType.Principal,prefix:PostConditionPrincipalID.Standard,address:createAddress(e)}}function te(e,t){return {type:StacksMessageType.Principal,prefix:PostConditionPrincipalID.Contract,contractName:createLPString(t),address:createAddress(e)}}function tt(e){let t=new BufferArray;return t.push(Uint8Array.from([e.prefix])),t.push(serializeAddress(e.address)),e.prefix===PostConditionPrincipalID.Contract&&t.push(serializeLPString(e.contractName)),t.concatBuffer()}function nt(e){let t=e.readUInt8Enum(PostConditionPrincipalID,i=>{throw new DeserializationError("Unexpected Principal payload type: ${n}")}),n=deserializeAddress(e);if(t===PostConditionPrincipalID.Standard)return {type:StacksMessageType.Principal,prefix:t,address:n};let r=deserializeLPString(e);return {type:StacksMessageType.Principal,prefix:t,address:n,contractName:r}}function Lt(e){return createLPString(e,4,1e5)}function Ye(e){if(e&&exceedsMaxLengthBytes(e,MEMO_MAX_LENGTH_BYTES))throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);return {type:StacksMessageType.MemoString,content:e}}function Cr(e){let t=new BufferArray,n=utf8ToBytes(e.content),r=kt(bytesToHex(n),MEMO_MAX_LENGTH_BYTES*2);return t.push(hexToBytes(r)),t.concatBuffer()}function Ce(e){let t=e.readBuffer(MEMO_MAX_LENGTH_BYTES),n=t.indexOf(0),r=bytesToUtf8(t.slice(0,n));return {type:StacksMessageType.MemoString,content:r}}function rt(e){let[t,n,r]=e.split(/\.|::/);return Tr(t,n,r)}function Tr(e,t,n){return {type:StacksMessageType.AssetInfo,address:createAddress(e),contractName:createLPString(t),assetName:createLPString(n)}}function it(e){let t=new BufferArray;return t.push(serializeAddress(e.address)),t.push(serializeLPString(e.contractName)),t.push(serializeLPString(e.assetName)),t.concatBuffer()}function G(e){return {type:StacksMessageType.AssetInfo,address:deserializeAddress(e),contractName:deserializeLPString(e),assetName:deserializeLPString(e)}}function T(e,t){return {type:StacksMessageType.LengthPrefixedList,lengthPrefixBytes:t||4,values:e}}function ne(e){let t=e.values,n=new BufferArray;n.appendHexString(intToHexString(t.length,e.lengthPrefixBytes));for(let r=0;r<t.length;r++)n.push(K(t[r]));return n.concatBuffer()}function re(e,t,n){let r=hexStringToInt(bytesToHex(e.readBuffer(n||4))),i=[];for(let o=0;o<r;o++)switch(t){case StacksMessageType.Address:i.push(deserializeAddress(e));break;case StacksMessageType.LengthPrefixedString:i.push(deserializeLPString(e));break;case StacksMessageType.MemoString:i.push(Ce(e));break;case StacksMessageType.AssetInfo:i.push(G(e));break;case StacksMessageType.PostCondition:i.push(Ae(e));break;case StacksMessageType.PublicKey:i.push($(e));break;case StacksMessageType.TransactionAuthField:i.push(Xt(e));break}return T(i,n)}var Rt=class{static deserialize(t){let n=new this;return n.deserialize(t),n}};function v(e){if(hexToBytes(e).byteLength!=RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)throw Error("Invalid signature");return {type:StacksMessageType.MessageSignature,data:e}}function Ue(){return {type:StacksMessageType.MessageSignature,data:bytesToHex(new Uint8Array(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).fill(0))}}function ze(e){let t=new BufferArray;return t.appendHexString(e.data),t.concatBuffer()}function ie(e){return v(bytesToHex(e.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)))}var Yt=(i=>(i[i.PublicKeyCompressed=0]="PublicKeyCompressed",i[i.PublicKeyUncompressed=1]="PublicKeyUncompressed",i[i.SignatureCompressed=2]="SignatureCompressed",i[i.SignatureUncompressed=3]="SignatureUncompressed",i))(Yt||{});function L(e,t){return {pubKeyEncoding:e,type:StacksMessageType.TransactionAuthField,contents:t}}function Wt(e){let t=new BufferArray;switch(e.contents.type){case StacksMessageType.PublicKey:e.pubKeyEncoding==0?(t.appendByte(0),t.push(H(e.contents))):(t.appendByte(1),t.push(H(Ft(e.contents.data))));break;case StacksMessageType.MessageSignature:e.pubKeyEncoding==0?t.appendByte(2):t.appendByte(3),t.push(ze(e.contents));break}return t.concatBuffer()}function Xt(e){let t=e.readUInt8Enum(Yt,n=>{throw new DeserializationError(`Could not read ${n} as AuthFieldType`)});switch(t){case 0:return L(0,$(e));case 1:return L(1,$(e));case 2:return L(0,ie(e));case 3:return L(1,ie(e));default:throw new Error(`Unknown auth field type: ${JSON.stringify(t)}`)}}function A(e,t,n,r){let i=j(0,e,1,[N(t)]).hash160,o=k(N(t))?0:1;return {hashMode:e,signer:i,nonce:intToBigInt(n,!1),fee:intToBigInt(r,!1),keyEncoding:o,signature:Ue()}}function Ne(e,t,n,r,i){let o=n.map(N),s=j(0,e,t,o).hash160;return {hashMode:e,signer:s,nonce:intToBigInt(r,!1),fee:intToBigInt(i,!1),fields:[],signaturesRequired:t}}function w(e){return "signature"in e}function qt(e){let t=cloneDeep(e);return t.nonce=0,t.fee=0,w(t)?t.signature=Ue():t.fields=[],{...t,nonce:BigInt(0),fee:BigInt(0)}}function Ar(e){let t=new BufferArray;return t.appendByte(e.hashMode),t.appendHexString(e.signer),t.push(intToBytes(e.nonce,!1,8)),t.push(intToBytes(e.fee,!1,8)),t.appendByte(e.keyEncoding),t.push(ze(e.signature)),t.concatBuffer()}function wr(e){let t=new BufferArray;t.appendByte(e.hashMode),t.appendHexString(e.signer),t.push(intToBytes(e.nonce,!1,8)),t.push(intToBytes(e.fee,!1,8));let n=T(e.fields);t.push(ne(n));let r=new Uint8Array(2);return writeUInt16BE(r,e.signaturesRequired,0),t.push(r),t.concatBuffer()}function kr(e,t){let n=bytesToHex(t.readBuffer(20)),r=BigInt("0x"+bytesToHex(t.readBuffer(8))),i=BigInt("0x"+bytesToHex(t.readBuffer(8))),o=t.readUInt8Enum(ye,a=>{throw new DeserializationError(`Could not parse ${a} as PubKeyEncoding`)});if(e===2&&o!=0)throw new DeserializationError("Failed to parse singlesig spending condition: incomaptible hash mode and key encoding");let s=ie(t);return {hashMode:e,signer:n,nonce:r,fee:i,keyEncoding:o,signature:s}}function Br(e,t){let n=bytesToHex(t.readBuffer(20)),r=BigInt("0x"+bytesToHex(t.readBuffer(8))),i=BigInt("0x"+bytesToHex(t.readBuffer(8))),o=re(t,StacksMessageType.TransactionAuthField).values,s=!1,a=0;for(let p of o)switch(p.contents.type){case StacksMessageType.PublicKey:k(p.contents)||(s=!0);break;case StacksMessageType.MessageSignature:if(p.pubKeyEncoding===1&&(s=!0),a+=1,a===65536)throw new TypeError("Failed to parse multisig spending condition: too many signatures");break}let c=t.readUInt16BE();if(s&&e===3)throw new TypeError("Public keys must be compressed for segwit");return {hashMode:e,signer:n,nonce:r,fee:i,fields:o,signaturesRequired:c}}function at(e){return w(e)?Ar(e):wr(e)}function ct(e){let t=e.readUInt8Enum(De,n=>{throw new DeserializationError(`Could not parse ${n} as AddressHashMode`)});return t===0||t===2?kr(t,e):Br(t,e)}function Zt(e,t,n,r){let o=[hexToBytes(e),Uint8Array.from([t]),intToBytes(n,!1,8),intToBytes(r,!1,8)],s=concatByteArrays(o);if(s.byteLength!==49)throw Error("Invalid signature hash length");return X(s)}function Qt(e,t,n){let r=33+RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,i=k(t)?0:1,o=e+wt(i.toString(16))+n.data,s=hexToBytes(o);if(s.byteLength>r)throw Error("Invalid signature hash length");return X(s)}async function jt(e,t,n,r,i){let o=Zt(e,t,n,r),s=await Ut(i,o),a=I(i),c=Qt(o,a,s);return {nextSig:s,nextSigHash:c}}function He(e,t,n,r,i,o){let s=Zt(e,t,n,r),a=N(zt(s,o,i)),c=Qt(s,a,o);return {pubKey:a,nextSigHash:c}}function Mr(){let e=A(0,"",0,0);return e.signer=_t().hash160,e.keyEncoding=0,e.signature=Ue(),e}function Gt(e,t,n){return w(e)?Ir(e,t,n):Kr(e,t,n)}function Ir(e,t,n){let{nextSigHash:r,pubKey:i}=He(t,n,e.fee,e.nonce,e.keyEncoding,e.signature),o=j(0,e.hashMode,1,[i]).hash160;if(o!==e.signer)throw new TypeError(`Signer hash does not equal hash of public key(s): ${o} != ${e.signer}`);return r}function Kr(e,t,n){let r=[],i=t,o=!1,s=0;for(let c of e.fields){let p;switch(c.contents.type){case StacksMessageType.PublicKey:k(c.contents)||(o=!0),p=c.contents;break;case StacksMessageType.MessageSignature:c.pubKeyEncoding===1&&(o=!0);let{pubKey:l,nextSigHash:g}=He(i,n,e.fee,e.nonce,c.pubKeyEncoding,c.contents);if(i=g,p=l,s+=1,s===65536)throw new TypeError("Too many signatures");break}r.push(p);}if(s!==e.signaturesRequired)throw new TypeError("Incorrect number of signatures");if(o&&e.hashMode===3)throw new TypeError("Uncompressed keys are not allowed in this hash mode");let a=j(0,e.hashMode,e.signaturesRequired,r).hash160;if(a!==e.signer)throw new TypeError(`Signer hash does not equal hash of public key(s): ${a} != ${e.signer}`);return i}function z(e){return {authType:4,spendingCondition:e}}function F(e,t){return {authType:5,spendingCondition:e,sponsorSpendingCondition:t||A(0,"0".repeat(66),0,0)}}function dt(e){if(e.spendingCondition)switch(e.authType){case 4:return z(qt(e.spendingCondition));case 5:return F(qt(e.spendingCondition),Mr());default:throw new SigningError("Unexpected authorization type for signing")}throw new Error("Authorization missing SpendingCondition")}function en(e,t){switch(e.authType){case 4:return Gt(e.spendingCondition,t,4);case 5:return Gt(e.spendingCondition,t,4);default:throw new SigningError("Invalid origin auth type")}}function tn(e,t){switch(e.authType){case 4:let n={...e.spendingCondition,fee:intToBigInt(t,!1)};return {...e,spendingCondition:n};case 5:let r={...e.sponsorSpendingCondition,fee:intToBigInt(t,!1)};return {...e,sponsorSpendingCondition:r}}}function es(e){switch(e.authType){case 4:return e.spendingCondition.fee;case 5:return e.sponsorSpendingCondition.fee}}function nn(e,t){let n={...e.spendingCondition,nonce:intToBigInt(t,!1)};return {...e,spendingCondition:n}}function rn(e,t){let n={...e.sponsorSpendingCondition,nonce:intToBigInt(t,!1)};return {...e,sponsorSpendingCondition:n}}function on(e,t){let n={...t,nonce:intToBigInt(t.nonce,!1),fee:intToBigInt(t.fee,!1)};return {...e,sponsorSpendingCondition:n}}function sn(e){let t=new BufferArray;switch(t.appendByte(e.authType),e.authType){case 4:t.push(at(e.spendingCondition));break;case 5:t.push(at(e.spendingCondition)),t.push(at(e.sponsorSpendingCondition));break}return t.concatBuffer()}function an(e){let t=e.readUInt8Enum(le,r=>{throw new DeserializationError(`Could not parse ${r} as AuthType`)}),n;switch(t){case 4:return n=ct(e),z(n);case 5:n=ct(e);let r=ct(e);return F(n,r)}}var B=class{version;chainId;auth;anchorMode;payload;postConditionMode;postConditions;constructor(t,n,r,i,o,s,a){if(this.version=t,this.auth=n,"amount"in r?this.payload={...r,amount:intToBigInt(r.amount,!1)}:this.payload=r,this.chainId=a??DEFAULT_CHAIN_ID,this.postConditionMode=o??2,this.postConditions=i??T([]),s)this.anchorMode=s;else switch(r.payloadType){case 4:case 3:{this.anchorMode=1;break}case 2:case 1:case 0:{this.anchorMode=3;break}}}signBegin(){let t=cloneDeep(this);return t.auth=dt(t.auth),t.txid()}verifyBegin(){let t=cloneDeep(this);return t.auth=dt(t.auth),t.txid()}createTxWithSignature(t){let n=typeof t=="string"?t:bytesToHex(t),r=cloneDeep(this);if(!r.auth.spendingCondition)throw new Error("Cannot set signature on transaction without spending condition");return r.auth.spendingCondition.signature=v(n),r}verifyOrigin(){return en(this.auth,this.verifyBegin())}async signNextOrigin(t,n){if(this.auth.spendingCondition===void 0)throw new Error('"auth.spendingCondition" is undefined');if(this.auth.authType===void 0)throw new Error('"auth.authType" is undefined');return this.signAndAppend(this.auth.spendingCondition,t,4,n)}async signNextSponsor(t,n){if(this.auth.authType===5)return await this.signAndAppend(this.auth.sponsorSpendingCondition,t,5,n);throw new Error('"auth.sponsorSpendingCondition" is undefined')}appendPubkey(t){let n=this.auth.spendingCondition;if(n&&!w(n)){let r=k(t);n.fields.push(L(r?0:1,t));}else throw new Error("Can't append public key to a singlesig condition")}async signAndAppend(t,n,r,i){let{nextSig:o,nextSigHash:s}=await jt(n,r,t.fee,t.nonce,i);if(w(t))t.signature=o;else {let a=i.compressed||qe(i.data);t.fields.push(L(a?0:1,o));}return s}txid(){let t=this.serialize();return X(t)}setSponsor(t){if(this.auth.authType!=5)throw new SigningError("Cannot sponsor sign a non-sponsored transaction");this.auth=on(this.auth,t);}setFee(t){this.auth=tn(this.auth,t);}setNonce(t){this.auth=nn(this.auth,t);}setSponsorNonce(t){if(this.auth.authType!=5)throw new SigningError("Cannot sponsor sign a non-sponsored transaction");this.auth=rn(this.auth,t);}serialize(){if(this.version===void 0)throw new SerializationError('"version" is undefined');if(this.chainId===void 0)throw new SerializationError('"chainId" is undefined');if(this.auth===void 0)throw new SerializationError('"auth" is undefined');if(this.anchorMode===void 0)throw new SerializationError('"anchorMode" is undefined');if(this.payload===void 0)throw new SerializationError('"payload" is undefined');let t=new BufferArray;t.appendByte(this.version);let n=new Uint8Array(4);return writeUInt32BE(n,this.chainId,0),t.push(n),t.push(sn(this.auth)),t.appendByte(this.anchorMode),t.appendByte(this.postConditionMode),t.push(ne(this.postConditions)),t.push(Se(this.payload)),t.concatBuffer()}};function Lr(e){let t;typeof e=="string"?e.slice(0,2).toLowerCase()==="0x"?t=new BufferReader(hexToBytes(e.slice(2))):t=new BufferReader(hexToBytes(e)):e instanceof Uint8Array?t=new BufferReader(e):t=e;let n=t.readUInt8Enum(TransactionVersion,p=>{throw new Error(`Could not parse ${p} as TransactionVersion`)}),r=t.readUInt32BE(),i=an(t),o=t.readUInt8Enum($e,p=>{throw new Error(`Could not parse ${p} as AnchorMode`)}),s=t.readUInt8Enum(ve,p=>{throw new Error(`Could not parse ${p} as PostConditionMode`)}),a=re(t,StacksMessageType.PostCondition),c=me(t);return new B(n,i,c,a,s,o,r)}var gt=e=>typeof e=="string",ft=e=>e.buffer!==void 0,hn=e=>e["string-ascii"]!==void 0,Sn=e=>e["string-utf8"]!==void 0,ht=e=>e.response!==void 0,St=e=>e.optional!==void 0,mt=e=>e.tuple!==void 0,Ct=e=>e.list!==void 0;function mn(e){if(gt(e)){if(e==="uint128")return {id:ClarityAbiTypeId.ClarityAbiTypeUInt128,type:e};if(e==="int128")return {id:ClarityAbiTypeId.ClarityAbiTypeInt128,type:e};if(e==="bool")return {id:ClarityAbiTypeId.ClarityAbiTypeBool,type:e};if(e==="principal")return {id:ClarityAbiTypeId.ClarityAbiTypePrincipal,type:e};if(e==="trait_reference")return {id:ClarityAbiTypeId.ClarityAbiTypeTraitReference,type:e};if(e==="none")return {id:ClarityAbiTypeId.ClarityAbiTypeNone,type:e};throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(e)}`)}else {if(ft(e))return {id:ClarityAbiTypeId.ClarityAbiTypeBuffer,type:e};if(ht(e))return {id:ClarityAbiTypeId.ClarityAbiTypeResponse,type:e};if(St(e))return {id:ClarityAbiTypeId.ClarityAbiTypeOptional,type:e};if(mt(e))return {id:ClarityAbiTypeId.ClarityAbiTypeTuple,type:e};if(Ct(e))return {id:ClarityAbiTypeId.ClarityAbiTypeList,type:e};if(hn(e))return {id:ClarityAbiTypeId.ClarityAbiTypeStringAscii,type:e};if(Sn(e))return {id:ClarityAbiTypeId.ClarityAbiTypeStringUtf8,type:e};throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(e)}`)}}function Hs(e,t){let n;switch(e.id!==void 0?n=e:n=mn(e),n.id){case ClarityAbiTypeId.ClarityAbiTypeUInt128:return uintCV(t);case ClarityAbiTypeId.ClarityAbiTypeInt128:return intCV(t);case ClarityAbiTypeId.ClarityAbiTypeBool:if(t==="false"||t==="0")return falseCV();if(t==="true"||t==="1")return trueCV();throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(t)}`);case ClarityAbiTypeId.ClarityAbiTypePrincipal:if(t.includes(".")){let[o,s]=t.split(".");return contractPrincipalCV(o,s)}else return standardPrincipalCV(t);case ClarityAbiTypeId.ClarityAbiTypeTraitReference:let[r,i]=t.split(".");return contractPrincipalCV(r,i);case ClarityAbiTypeId.ClarityAbiTypeNone:return noneCV();case ClarityAbiTypeId.ClarityAbiTypeBuffer:return bufferCV(utf8ToBytes(t));case ClarityAbiTypeId.ClarityAbiTypeStringAscii:return stringAsciiCV(t);case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:return stringUtf8CV(t);case ClarityAbiTypeId.ClarityAbiTypeResponse:throw new NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);case ClarityAbiTypeId.ClarityAbiTypeOptional:throw new NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);case ClarityAbiTypeId.ClarityAbiTypeTuple:throw new NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);case ClarityAbiTypeId.ClarityAbiTypeList:throw new NotImplementedError(`Unsupported encoding for Clarity type: ${n.id}`);default:throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(n)}`)}}function U(e){if(gt(e))return e==="int128"?"int":e==="uint128"?"uint":e;if(ft(e))return `(buff ${e.buffer.length})`;if(hn(e))return `(string-ascii ${e["string-ascii"].length})`;if(Sn(e))return `(string-utf8 ${e["string-utf8"].length})`;if(ht(e))return `(response ${U(e.response.ok)} ${U(e.response.error)})`;if(St(e))return `(optional ${U(e.optional)})`;if(mt(e))return `(tuple ${e.tuple.map(t=>`(${t.name} ${U(t.type)})`).join(" ")})`;if(Ct(e))return `(list ${e.list.length} ${U(e.list.type)})`;throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(e)}`)}function Os(e){return `(define-${e.access==="read_only"?"read-only":e.access} (${e.name} ${e.args.map(n=>`(${n.name} ${U(n.type)})`).join(" ")}))`}function _(e,t){let n=mn(t);switch(e.type){case ClarityType.BoolTrue:case ClarityType.BoolFalse:return n.id===ClarityAbiTypeId.ClarityAbiTypeBool;case ClarityType.Int:return n.id===ClarityAbiTypeId.ClarityAbiTypeInt128;case ClarityType.UInt:return n.id===ClarityAbiTypeId.ClarityAbiTypeUInt128;case ClarityType.Buffer:return n.id===ClarityAbiTypeId.ClarityAbiTypeBuffer&&n.type.buffer.length>=e.buffer.length;case ClarityType.StringASCII:return n.id===ClarityAbiTypeId.ClarityAbiTypeStringAscii&&n.type["string-ascii"].length>=e.data.length;case ClarityType.StringUTF8:return n.id===ClarityAbiTypeId.ClarityAbiTypeStringUtf8&&n.type["string-utf8"].length>=e.data.length;case ClarityType.OptionalNone:return n.id===ClarityAbiTypeId.ClarityAbiTypeNone||n.id===ClarityAbiTypeId.ClarityAbiTypeOptional;case ClarityType.OptionalSome:return n.id===ClarityAbiTypeId.ClarityAbiTypeOptional&&_(e.value,n.type.optional);case ClarityType.ResponseErr:return n.id===ClarityAbiTypeId.ClarityAbiTypeResponse&&_(e.value,n.type.response.error);case ClarityType.ResponseOk:return n.id===ClarityAbiTypeId.ClarityAbiTypeResponse&&_(e.value,n.type.response.ok);case ClarityType.PrincipalContract:return n.id===ClarityAbiTypeId.ClarityAbiTypePrincipal||n.id===ClarityAbiTypeId.ClarityAbiTypeTraitReference;case ClarityType.PrincipalStandard:return n.id===ClarityAbiTypeId.ClarityAbiTypePrincipal;case ClarityType.List:return n.id==ClarityAbiTypeId.ClarityAbiTypeList&&n.type.list.length>=e.list.length&&e.list.every(r=>_(r,n.type.list.type));case ClarityType.Tuple:if(n.id==ClarityAbiTypeId.ClarityAbiTypeTuple){let r=cloneDeep(e.data);for(let i=0;i<n.type.tuple.length;i++){let o=n.type.tuple[i],s=o.name,a=r[s];if(a){if(!_(a,o.type))return !1;delete r[s];}else return !1}return !0}else return !1;default:return !1}}function Cn(e,t){let n=t.functions.filter(r=>r.name===e.functionName.content);if(n.length===1){let i=n[0].args;if(e.functionArgs.length!==i.length)throw new Error(`Clarity function expects ${i.length} argument(s) but received ${e.functionArgs.length}`);for(let o=0;o<e.functionArgs.length;o++){let s=e.functionArgs[o],a=i[o];if(!_(s,a.type)){let c=o+1;throw new Error(`Clarity function \`${e.functionName.content}\` expects argument ${c} to be of type ${U(a.type)}, not ${getCVTypeString(s)}`)}}return !0}else throw n.length===0?new Error(`ABI doesn't contain a function with the name ${e.functionName.content}`):new Error(`Malformed ABI. Contains multiple functions with the name ${e.functionName.content}`)}function Ls(e,t){let n=U(t);if(gt(t)){if(t==="uint128")return uintCV(e);if(t==="int128")return intCV(e);if(t==="bool"){if(e.toLowerCase()==="true")return trueCV();if(e.toLowerCase()==="false")return falseCV();throw new Error(`Invalid bool value: ${e}`)}else if(t==="principal")if(e.includes(".")){let[r,i]=e.split(".");return contractPrincipalCV(r,i)}else return standardPrincipalCV(e);else throw new Error(`Contract function contains unsupported Clarity ABI type: ${n}`)}else if(ft(t)){if(utf8ToBytes(e).byteLength>t.buffer.length)throw new Error(`Input exceeds specified buffer length limit of ${t.buffer.length}`);return bufferCVFromString(e)}else throw ht(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):St(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):mt(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):Ct(t)?new Error(`Contract function contains unsupported Clarity ABI type: ${n}`):new Error(`Contract function contains unsupported Clarity ABI type: ${n}`)}var m=class{transaction;sigHash;originDone;checkOversign;checkOverlap;constructor(t){this.transaction=t,this.sigHash=t.signBegin(),this.originDone=!1,this.checkOversign=!0,this.checkOverlap=!0;let n=t.auth.spendingCondition;if(n&&!w(n)){if(n.fields.filter(r=>r.contents.type===StacksMessageType.MessageSignature).length>=n.signaturesRequired)throw new Error("SpendingCondition has more signatures than are expected");n.fields.forEach(r=>{if(r.contents.type===StacksMessageType.MessageSignature){let i=r.contents,o=He(this.sigHash,t.auth.authType,n.fee,n.nonce,0,i);this.sigHash=o.nextSigHash;}});}}static createSponsorSigner(t,n){if(t.auth.authType!=5)throw new SigningError("Cannot add sponsor to non-sponsored transaction");let r=cloneDeep(t);r.setSponsor(n);let i=r.verifyOrigin(),o=new this(r);return o.originDone=!0,o.sigHash=i,o.checkOversign=!0,o.checkOverlap=!0,o}async signOrigin(t){if(this.checkOverlap&&this.originDone)throw new SigningError("Cannot sign origin after sponsor key");if(this.transaction.auth===void 0)throw new SigningError('"transaction.auth" is undefined');if(this.transaction.auth.spendingCondition===void 0)throw new SigningError('"transaction.auth.spendingCondition" is undefined');if(!w(this.transaction.auth.spendingCondition)){let n=this.transaction.auth.spendingCondition;if(this.checkOversign&&n.fields.filter(r=>r.contents.type===StacksMessageType.MessageSignature).length>=n.signaturesRequired)throw new Error("Origin would have too many signatures")}this.sigHash=await this.transaction.signNextOrigin(this.sigHash,t);}appendOrigin(t){if(this.checkOverlap&&this.originDone)throw Error("Cannot append public key to origin after sponsor key");if(this.transaction.auth===void 0)throw new Error('"transaction.auth" is undefined');if(this.transaction.auth.spendingCondition===void 0)throw new Error('"transaction.auth.spendingCondition" is undefined');this.transaction.appendPubkey(t);}async signSponsor(t){if(this.transaction.auth===void 0)throw new SigningError('"transaction.auth" is undefined');if(this.transaction.auth.authType!==5)throw new SigningError('"transaction.auth.authType" is not AuthType.Sponsored');this.sigHash=await this.transaction.signNextSponsor(this.sigHash,t),this.originDone=!0;}getTxInComplete(){return cloneDeep(this.transaction)}resume(t){this.transaction=cloneDeep(t),this.sigHash=t.signBegin();}};async function M(e,t){let n=new StacksMainnet,r=t?t.getAccountApiUrl(e):n.getAccountApiUrl(e),i=await fetchPrivate(r);if(!i.ok){let a="";try{a=await i.text();}catch{}throw new Error(`Error fetching nonce. Response ${i.status}: ${i.statusText}. Attempted to fetch ${r} and failed with the message: "${a}"`)}let o=await i.text(),s=JSON.parse(o);return BigInt(s.nonce)}async function ce(e,t){if(e.payload.payloadType!==0)throw new Error(`Transaction fee estimation only possible with ${h[0]} transactions. Invoked with: ${h[e.payload.payloadType]}`);let r={method:"GET",headers:{Accept:"application/text"}},i=new StacksMainnet,o=t?t.getTransferFeeEstimateApiUrl():i.getTransferFeeEstimateApiUrl(),s=await fetchPrivate(o,r);if(!s.ok){let l="";try{l=await s.text();}catch{}throw new Error(`Error estimating transaction fee. Response ${s.status}: ${s.statusText}. Attempted to fetch ${o} and failed with the message: "${l}"`)}let a=await s.text(),c=BigInt(e.serialize().byteLength);return BigInt(a)*c}async function pe(e,t){if(e.payload.payloadType!==2)throw new Error(`Contract call fee estimation only possible with ${h[2]} transactions. Invoked with: ${h[e.payload.payloadType]}`);let r={method:"GET",headers:{Accept:"application/text"}},i=new StacksMainnet,o=t?t.getTransferFeeEstimateApiUrl():i.getTransferFeeEstimateApiUrl(),s=await fetchPrivate(o,r);if(!s.ok){let l="";try{l=await s.text();}catch{}throw new Error(`Error estimating contract call fee. Response ${s.status}: ${s.statusText}. Attempted to fetch ${o} and failed with the message: "${l}"`)}let a=await s.text(),c=intToBigInt(e.serialize().byteLength,!1);return intToBigInt(a,!1)*c}async function de(e,t){if(e.payload.payloadType!==1)throw new Error(`Contract deploy fee estimation only possible with ${h[1]} transactions. Invoked with: ${h[e.payload.payloadType]}`);let r={method:"GET",headers:{Accept:"application/text"}},i=new StacksMainnet,o=t?t.getTransferFeeEstimateApiUrl():i.getTransferFeeEstimateApiUrl(),s=await fetchPrivate(o,r);if(!s.ok){let l="";try{l=await s.text();}catch{}throw new Error(`Error estimating contract deploy fee. Response ${s.status}: ${s.statusText}. Attempted to fetch ${o} and failed with the message: "${l}"`)}let a=await s.text(),c=intToBigInt(e.serialize().byteLength,!1);return intToBigInt(a,!1)*c}async function ri(e){let t={fee:0,sponsorNonce:0,sponsorAddressHashmode:0},n=Object.assign(t,e),r=e.network??(n.transaction.version===TransactionVersion.Mainnet?new StacksMainnet:new StacksTestnet),i=O(n.sponsorPrivateKey);if(e.fee===void 0||e.fee===null){let c=BigInt(0);switch(n.transaction.payload.payloadType){case 0:c=await ce(n.transaction,r);break;case 1:c=await de(n.transaction,r);break;case 2:c=await pe(n.transaction,r);break;default:throw new Error(`Sponsored transactions not supported for transaction type ${h[n.transaction.payload.payloadType]}`)}n.transaction.setFee(c),n.fee=c;}if(e.sponsorNonce===void 0||e.sponsorNonce===null){let c=r.version===TransactionVersion.Mainnet?StacksNetworkVersion.mainnetP2PKH:StacksNetworkVersion.testnetP2PKH,p=publicKeyToStxAddress(C(i),c),l=await M(p,r);n.sponsorNonce=l;}let o=A(n.sponsorAddressHashmode,C(i),n.sponsorNonce,n.fee);n.transaction.setSponsor(o);let s=S(n.sponsorPrivateKey),a=m.createSponsorSigner(n.transaction,o);return await a.signSponsor(s),a.transaction}function oi(e,t,n){return Pe(ee(e),t,n)}function si(e,t,n,r){return Pe(te(e,t),n,r)}function ai(e,t,n,r){return be(ee(e),t,n,r)}function ci(e,t,n,r,i){return be(te(e,t),n,r,i)}function pi(e,t,n,r){return xe(ee(e),t,n,r)}function di(e,t,n,r,i){return xe(te(e,t),n,r,i)}async function bt(e,t,n){let r={method:"GET"},i=n.getAbiApiUrl(e,t),o=await fetchPrivate(i,r);if(!o.ok){let s="";try{s=await o.text();}catch{}throw new Error(`Error fetching contract ABI for contract "${t}" at address ${e}. Response ${o.status}: ${o.statusText}. Attempted to fetch ${i} and failed with the message: "${s}"`)}return JSON.parse(await o.text())}async function xt(e){let t={fee:BigInt(0),nonce:BigInt(0),network:new StacksMainnet,postConditionMode:2,sponsored:!1},n=Object.assign(t,e),r=Qe(n.contractAddress,n.contractName,n.functionName,n.functionArgs);if(n!=null&&n.validateWithAbi){let p;if(typeof n.validateWithAbi=="boolean")if(n!=null&&n.network)p=await bt(n.contractAddress,n.contractName,n.network);else throw new Error("Network option must be provided in order to validate with ABI");else p=n.validateWithAbi;Cn(r,p);}let i=null,o=null;"publicKey"in n?i=A(0,n.publicKey,n.nonce,n.fee):i=Ne(1,n.numSignatures,n.publicKeys,n.nonce,n.fee),n.sponsored?o=F(i):o=z(i);let s=[];n.postConditions&&n.postConditions.length>0&&n.postConditions.forEach(p=>{s.push(p);});let a=T(s),c=new B(n.network.version,o,r,a,n.postConditionMode,n.anchorMode,n.network.chainId);if(e.fee===void 0||e.fee===null){let p=await pe(c,n.network);c.setFee(p);}if(e.nonce===void 0||e.nonce===null){let p=n.network.version===TransactionVersion.Mainnet?StacksNetworkVersion.mainnetP2PKH:StacksNetworkVersion.testnetP2PKH,l=c32address(p,hexToBytes(c.auth.spendingCondition.signer)),g=await M(l,n.network);c.setNonce(g);}return c}async function hi(e){if("senderKey"in e){let t=S(e.senderKey),n=C(I(t)),r=omit(e,"senderKey"),i=await xt({publicKey:n,...r});return await new m(i).signOrigin(t),i}else {let t=omit(e,"signerKeys"),n=await xt(t),r=new m(n),i=e.publicKeys;for(let o of e.signerKeys){let s=O(o);i=i.filter(a=>a!==bytesToHex(s.data)),await r.signOrigin(S(o));}for(let o of i)r.appendOrigin(R(hexToBytes(o)));return n}}async function Ti(e){let t={fee:BigInt(0),nonce:BigInt(0),network:new StacksMainnet,postConditionMode:2,sponsored:!1},n=Object.assign(t,e),r=je(n.contractName,n.codeBody),i=0,o=S(n.senderKey),s=I(o),a=null,c=A(i,C(s),n.nonce,n.fee);n.sponsored?a=F(c):a=z(c);let p=[];n.postConditions&&n.postConditions.length>0&&n.postConditions.forEach(P=>{p.push(P);});let l=T(p),g=new B(n.network.version,a,r,l,n.postConditionMode,n.anchorMode,n.network.chainId);if(e.fee===void 0||e.fee===null){let P=await de(g,n.network);g.setFee(P);}if(e.nonce===void 0||e.nonce===null){let P=n.network.version===TransactionVersion.Mainnet?StacksNetworkVersion.mainnetP2PKH:StacksNetworkVersion.testnetP2PKH,ue=publicKeyToStxAddress(C(s),P),Le=await M(ue,n.network);g.setNonce(Le);}return n.senderKey&&await new m(g).signOrigin(o),g}async function At(e,t){let n={fee:BigInt(0),nonce:BigInt(0),network:new StacksMainnet,postConditionMode:2,memo:"",sponsored:!1},r=Object.assign(n,e),i=Ze(r.recipient,r.amount,r.memo),o=null,s=null;"publicKey"in r?s=A(0,r.publicKey,r.nonce,r.fee):s=Ne(1,r.numSignatures,r.publicKeys,r.nonce,r.fee),r.sponsored?o=F(s):o=z(s);let a=[];r.postConditions&&r.postConditions.length>0&&r.postConditions.forEach(l=>{a.push(l);});let c=T(a),p=new B(r.network.version,o,i,c,r.postConditionMode,r.anchorMode,r.network.chainId);if(t)p.setFee(0),p.setNonce(0);else {if(e.fee===void 0||e.fee===null){let l=await ce(p,r.network);p.setFee(l);}if(e.nonce===void 0||e.nonce===null){let l=r.network.version===TransactionVersion.Mainnet?StacksNetworkVersion.mainnetP2PKH:StacksNetworkVersion.testnetP2PKH,g=c32address(l,hexToBytes(p.auth.spendingCondition.signer)),P=await M(g,r.network);p.setNonce(P);}}return p}async function wi(e){if("senderKey"in e){let t=S(e.senderKey),n=C(I(t)),r=omit(e,"senderKey"),i=await At({publicKey:n,...r});return await new m(i).signOrigin(t),i}else {let t=omit(e,"signerKeys"),n=await At(t),r=new m(n),i=e.publicKeys;for(let o of e.signerKeys){let s=O(o);i=i.filter(a=>a!==bytesToHex(s.data)),await r.signOrigin(S(o));}for(let o of i)r.appendOrigin(R(hexToBytes(o)));return n}}function zn(e){return e.startsWith("0x")?e:`0x${e}`}var Bi=e=>{if(e==="success")return !0;let t=zn(e).toLowerCase();return t.length!==66?!1:zn(BigInt(t).toString(16).padStart(64,"0"))===t};async function Mi(e,t,n){return Fn(e.serialize(),t.getBroadcastApiUrl(),n)}async function Fn(e,t,n){let r={method:"POST",headers:{"Content-Type":n?"application/json":"application/octet-stream"},body:n?JSON.stringify({tx:bytesToHex(e),attachment:bytesToHex(n)}):e},i=await fetchPrivate(t,r);if(!i.ok)try{return await i.json()}catch(a){throw Error(`Failed to broadcast transaction: ${a.message}`)}let o=await i.text(),s=o.replace(/["]+/g,"");if(Bi(s))return {txid:s};throw new Error(o)}

export { De as AddressHashMode, Nn as AddressVersion, $e as AnchorMode, Hn as AssetType, le as AuthType, Ki as CLARITY_INT_BYTE_SIZE, Ei as DEFAULT_CORE_NODE_API_URL, zi as DEFAULT_TRANSACTION_VERSION, Rt as Deserializable, ge as FungibleConditionCode, _e as NonFungibleConditionCode, ve as PostConditionMode, Ve as PostConditionType, ye as PubKeyEncoding, m as TransactionSigner, On as TxRejectedReason, Os as abiFunctionToString, vo as addressFromHashMode, j as addressFromPublicKeys, Y as addressFromVersionHash, mr as addressHashModeToVersion, Fn as broadcastRawTransaction, Mi as broadcastTransaction, Lt as codeBodyString, Ft as compressPublicKey, Tr as createAssetInfo, te as createContractPrincipal, _t as createEmptyAddress, be as createFungiblePostCondition, T as createLPList, Ye as createMemoString, v as createMessageSignature, Ne as createMultiSigSpendingCondition, xe as createNonFungiblePostCondition, Pe as createSTXPostCondition, A as createSingleSigSpendingCondition, F as createSponsoredAuth, S as createStacksPrivateKey, N as createStacksPublicKey, z as createStandardAuth, ee as createStandardPrincipal, L as createTransactionAuthField, G as deserializeAssetInfo, an as deserializeAuthorization, re as deserializeLPList, Ce as deserializeMemoString, ie as deserializeMessageSignature, Br as deserializeMultiSigSpendingCondition, Ae as deserializePostCondition, nt as deserializePrincipal, $ as deserializePublicKey, kr as deserializeSingleSigSpendingCondition, ct as deserializeSpendingCondition, $o as deserializeStacksMessage, Lr as deserializeTransaction, Xt as deserializeTransactionAuthField, Ue as emptyMessageSignature, Hs as encodeClarityValue, de as estimateContractDeploy, pe as estimateContractFunctionCall, ce as estimateTransfer, bt as getAbi, es as getFee, M as getNonce, I as getPublicKeyFromStacksPrivateKey, Gi as getSignatureRecoveryParam, U as getTypeString, mn as getTypeUnion, dt as intoInitialSighashAuth, ft as isClarityAbiBuffer, Ct as isClarityAbiList, St as isClarityAbiOptional, gt as isClarityAbiPrimitive, ht as isClarityAbiResponse, hn as isClarityAbiStringAscii, Sn as isClarityAbiStringUtf8, mt as isClarityAbiTuple, k as isCompressed, qe as isPrivateKeyCompressed, w as isSingleSig, wt as leftPadHex, We as leftPadHexToLength, hi as makeContractCall, Ti as makeContractDeploy, ci as makeContractFungiblePostCondition, di as makeContractNonFungiblePostCondition, si as makeContractSTXPostCondition, qi as makeRandomPrivKey, wi as makeSTXTokenTransfer, Zt as makeSigHashPreSign, ai as makeStandardFungiblePostCondition, pi as makeStandardNonFungiblePostCondition, oi as makeStandardSTXPostCondition, xt as makeUnsignedContractCall, At as makeUnsignedSTXTokenTransfer, jt as nextSignature, He as nextVerification, rt as parseAssetInfoString, we as parsePrincipalString, Li as parseReadOnlyResponse, Jn as parseRecoverableSignature, Ls as parseToCV, Ji as privateKeyToString, O as pubKeyfromPrivKey, R as publicKeyFromBuffer, zt as publicKeyFromSignature, C as publicKeyToString, kt as rightPadHexToLength, it as serializeAssetInfo, sn as serializeAuthorization, ne as serializeLPList, Cr as serializeMemoString, ze as serializeMessageSignature, wr as serializeMultiSigSpendingCondition, et as serializePostCondition, tt as serializePrincipal, H as serializePublicKey, Ar as serializeSingleSigSpendingCondition, at as serializeSpendingCondition, K as serializeStacksMessage, Wt as serializeTransactionAuthField, tn as setFee, nn as setNonce, on as setSponsor, rn as setSponsorNonce, Ut as signWithKey, ri as sponsorTransaction, X as txidFromData, Cn as validateContractCall, en as verifyOrigin };
