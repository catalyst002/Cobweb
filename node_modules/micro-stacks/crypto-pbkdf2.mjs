import { getCryptoLib } from 'micro-stacks/crypto-aes';
import { ensureUint8Array, utf8ToBytes } from 'micro-stacks/common';
import { pbkdf2Async } from '@noble/hashes/pbkdf2';
import { sha512 } from '@noble/hashes/sha512';

var m=class{nodePbkdf2;constructor(r){this.nodePbkdf2=r;}async derive(r,o,i,s,t){if(t!=="sha512"&&t!=="sha256")throw new Error(`Unsupported digest "${t}" for Pbkdf2`);return new Promise((n,p)=>{this.nodePbkdf2(r,o,i,s,t,(f,d)=>{f&&p(f),n(d);});})}};var b=class{webCrypto;constructor(r){this.webCrypto=r;}async derive(r,o,i,s,t){let n;if(t==="sha256")n="SHA-256";else if(t==="sha512")n="SHA-512";else throw new Error(`Unsupported Pbkdf2 digest algorithm "${t}"`);let p=await this.webCrypto.subtle.importKey("raw",utf8ToBytes(r),"PBKDF2",!1,["deriveBits"]),f=await this.webCrypto.subtle.deriveBits({name:"PBKDF2",salt:o,iterations:i,hash:{name:n}},p,s*8);return new Uint8Array(f)}};async function v(){try{let e=await getCryptoLib();return e.name==="webCrypto"?new b(e.lib):new m(e.lib.pbkdf2)}catch{return {derive(r,o,i,s,t="sha512"){return pbkdf2Async(sha512,ensureUint8Array(utf8ToBytes(r)),ensureUint8Array(o),{c:i,dkLen:s})}}}}

export { v as createPbkdf2 };
