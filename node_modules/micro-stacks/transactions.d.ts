import { BufferReader, IntegerType, TransactionVersion, ChainID } from 'micro-stacks/common';
import { StacksMessageType, PostConditionPrincipal, AssetInfo, ClarityValue, Address, LengthPrefixedString, StandardPrincipal, ContractPrincipal, PrincipalCV, ClarityAbiType, ClarityAbiTypePrimitive, ClarityAbiTypeBuffer, ClarityAbiTypeStringAscii, ClarityAbiTypeStringUtf8, ClarityAbiTypeResponse, ClarityAbiTypeOptional, ClarityAbiTypeTuple, ClarityAbiTypeList, ClarityAbiTypeUnion, ClarityAbiFunction, ClarityAbi } from 'micro-stacks/clarity';
import { StacksNetworkVersion } from 'micro-stacks/crypto';
import { StacksNetwork } from 'micro-stacks/network';
export { callReadOnlyFunction } from 'micro-stacks/api';

declare const CLARITY_INT_BYTE_SIZE = 16;
declare const DEFAULT_CORE_NODE_API_URL = "https://stacks-node-api.mainnet.stacks.co";
declare enum AnchorMode {
    OnChainOnly = 1,
    OffChainOnly = 2,
    Any = 3
}
declare const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;
declare enum PostConditionMode {
    Allow = 1,
    Deny = 2
}
declare enum PostConditionType {
    STX = 0,
    Fungible = 1,
    NonFungible = 2
}
declare enum AuthType {
    Standard = 4,
    Sponsored = 5
}
declare enum AddressHashMode {
    SerializeP2PKH = 0,
    SerializeP2SH = 1,
    SerializeP2WPKH = 2,
    SerializeP2WSH = 3
}
declare type SingleSigHashMode = AddressHashMode.SerializeP2PKH | AddressHashMode.SerializeP2WPKH;
declare type MultiSigHashMode = AddressHashMode.SerializeP2SH | AddressHashMode.SerializeP2WSH;
declare enum AddressVersion {
    MainnetSingleSig = 22,
    MainnetMultiSig = 20,
    TestnetSingleSig = 26,
    TestnetMultiSig = 21
}
declare enum PubKeyEncoding {
    Compressed = 0,
    Uncompressed = 1
}
declare enum FungibleConditionCode {
    Equal = 1,
    Greater = 2,
    GreaterEqual = 3,
    Less = 4,
    LessEqual = 5
}
declare enum NonFungibleConditionCode {
    DoesNotOwn = 16,
    Owns = 17
}
declare enum AssetType {
    STX = 0,
    Fungible = 1,
    NonFungible = 2
}
declare enum TxRejectedReason {
    Serialization = "Serialization",
    Deserialization = "Deserialization",
    SignatureValidation = "SignatureValidation",
    FeeTooLow = "FeeTooLow",
    BadNonce = "BadNonce",
    NotEnoughFunds = "NotEnoughFunds",
    NoSuchContract = "NoSuchContract",
    NoSuchPublicFunction = "NoSuchPublicFunction",
    BadFunctionArgument = "BadFunctionArgument",
    ContractAlreadyExists = "ContractAlreadyExists",
    PoisonMicroblocksDoNotConflict = "PoisonMicroblocksDoNotConflict",
    PoisonMicroblockHasUnknownPubKeyHash = "PoisonMicroblockHasUnknownPubKeyHash",
    PoisonMicroblockIsInvalid = "PoisonMicroblockIsInvalid",
    BadAddressVersionByte = "BadAddressVersionByte",
    NoCoinbaseViaMempool = "NoCoinbaseViaMempool",
    ServerFailureNoSuchChainTip = "ServerFailureNoSuchChainTip",
    ServerFailureDatabase = "ServerFailureDatabase",
    ServerFailureOther = "ServerFailureOther"
}

interface StacksPublicKey {
    readonly type: StacksMessageType.PublicKey;
    readonly data: Uint8Array;
}
declare function createStacksPublicKey(key: string): StacksPublicKey;
declare function publicKeyFromSignature(message: string, messageSignature: MessageSignature, pubKeyEncoding?: PubKeyEncoding, mode?: "vrs" | "rsv"): string;
declare function publicKeyFromBuffer(data: Uint8Array): StacksPublicKey;
declare function publicKeyToString(key: StacksPublicKey): string;
declare function isCompressed(key: StacksPublicKey): boolean;
declare function isPrivateKeyCompressed(key: string | Uint8Array): boolean;
declare function serializePublicKey(key: StacksPublicKey): Uint8Array;
declare function pubKeyfromPrivKey(privateKey: string | Uint8Array): StacksPublicKey;
declare function compressPublicKey(publicKey: string | Uint8Array): StacksPublicKey;
declare function deserializePublicKey(bufferReader: BufferReader): StacksPublicKey;
interface StacksPrivateKey {
    data: Uint8Array;
    compressed: boolean;
}
declare function createStacksPrivateKey(key: string | Uint8Array): StacksPrivateKey;
declare function makeRandomPrivKey(): StacksPrivateKey;
declare function signWithKey(privateKey: StacksPrivateKey, input: string): Promise<MessageSignature>;
declare function getSignatureRecoveryParam(signature: string): number;
declare function parseRecoverableSignature(signature: string, mode?: "vrs" | "rsv"): {
    recoveryParam: number;
    r: string;
    s: string;
};
declare function getPublicKeyFromStacksPrivateKey(privateKey: StacksPrivateKey): StacksPublicKey;
declare function privateKeyToString(privateKey: StacksPrivateKey): string;

declare abstract class Deserializable {
    abstract serialize(): Uint8Array;
    abstract deserialize(bufferReader: BufferReader): void;
    static deserialize<T extends Deserializable>(this: new () => T, bufferReader: BufferReader): T;
}
interface MessageSignature {
    readonly type: StacksMessageType.MessageSignature;
    data: string;
}
declare function createMessageSignature(signature: string): MessageSignature;
declare function emptyMessageSignature(): MessageSignature;
declare function serializeMessageSignature(messageSignature: MessageSignature): Uint8Array;
declare function deserializeMessageSignature(bufferReader: BufferReader): MessageSignature;
declare type TransactionAuthFieldContents = StacksPublicKey | MessageSignature;
interface TransactionAuthField {
    type: StacksMessageType.TransactionAuthField;
    pubKeyEncoding: PubKeyEncoding;
    contents: TransactionAuthFieldContents;
}
declare function createTransactionAuthField(pubKeyEncoding: PubKeyEncoding, contents: TransactionAuthFieldContents): TransactionAuthField;
declare function serializeTransactionAuthField(field: TransactionAuthField): Uint8Array;
declare function deserializeTransactionAuthField(bufferReader: BufferReader): TransactionAuthField;
interface SingleSigSpendingCondition {
    hashMode: SingleSigHashMode;
    signer: string;
    nonce: bigint;
    fee: bigint;
    keyEncoding: PubKeyEncoding;
    signature: MessageSignature;
}
interface SingleSigSpendingConditionOpts extends Omit<SingleSigSpendingCondition, 'nonce' | 'fee'> {
    nonce: IntegerType;
    fee: IntegerType;
}
interface MultiSigSpendingCondition {
    hashMode: MultiSigHashMode;
    signer: string;
    nonce: bigint;
    fee: bigint;
    fields: TransactionAuthField[];
    signaturesRequired: number;
}
interface MultiSigSpendingConditionOpts extends Omit<MultiSigSpendingCondition, 'nonce' | 'fee'> {
    nonce: IntegerType;
    fee: IntegerType;
}
declare type SpendingCondition = SingleSigSpendingCondition | MultiSigSpendingCondition;
declare type SpendingConditionOpts = SingleSigSpendingConditionOpts | MultiSigSpendingConditionOpts;
declare function createSingleSigSpendingCondition(hashMode: SingleSigHashMode, pubKey: string, nonce: IntegerType, fee: IntegerType): SingleSigSpendingCondition;
declare function createMultiSigSpendingCondition(hashMode: MultiSigHashMode, numSigs: number, pubKeys: string[], nonce: IntegerType, fee: IntegerType): MultiSigSpendingCondition;
declare function isSingleSig(condition: SpendingConditionOpts): condition is SingleSigSpendingConditionOpts;
declare function serializeSingleSigSpendingCondition(condition: SingleSigSpendingConditionOpts): Uint8Array;
declare function serializeMultiSigSpendingCondition(condition: MultiSigSpendingConditionOpts): Uint8Array;
declare function deserializeSingleSigSpendingCondition(hashMode: SingleSigHashMode, bufferReader: BufferReader): SingleSigSpendingCondition;
declare function deserializeMultiSigSpendingCondition(hashMode: MultiSigHashMode, bufferReader: BufferReader): MultiSigSpendingCondition;
declare function serializeSpendingCondition(condition: SpendingConditionOpts): Uint8Array;
declare function deserializeSpendingCondition(bufferReader: BufferReader): SpendingCondition;
declare function makeSigHashPreSign(curSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType): string;
declare function nextSignature(curSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType, privateKey: StacksPrivateKey): Promise<{
    nextSig: MessageSignature;
    nextSigHash: string;
}>;
declare function nextVerification(initialSigHash: string, authType: AuthType, fee: IntegerType, nonce: IntegerType, pubKeyEncoding: PubKeyEncoding, signature: MessageSignature): {
    pubKey: StacksPublicKey;
    nextSigHash: string;
};
declare type Authorization = StandardAuthorization | SponsoredAuthorization;
interface StandardAuthorization {
    authType: AuthType.Standard;
    spendingCondition: SpendingCondition;
}
interface SponsoredAuthorization {
    authType: AuthType.Sponsored;
    spendingCondition: SpendingCondition;
    sponsorSpendingCondition: SpendingCondition;
}
declare function createStandardAuth(spendingCondition: SpendingCondition): StandardAuthorization;
declare function createSponsoredAuth(spendingCondition: SpendingCondition, sponsorSpendingCondition?: SpendingCondition): Authorization;
declare function intoInitialSighashAuth(auth: Authorization): Authorization;
declare function verifyOrigin(auth: Authorization, initialSigHash: string): string;
declare function setFee(auth: Authorization, amount: IntegerType): Authorization;
declare function getFee(auth: Authorization): bigint;
declare function setNonce(auth: Authorization, nonce: IntegerType): Authorization;
declare function setSponsorNonce(auth: SponsoredAuthorization, nonce: IntegerType): Authorization;
declare function setSponsor(auth: SponsoredAuthorization, sponsorSpendingCondition: SpendingConditionOpts): Authorization;
declare function serializeAuthorization(auth: Authorization): Uint8Array;
declare function deserializeAuthorization(bufferReader: BufferReader): Authorization;

declare type PostCondition = STXPostCondition | FungiblePostCondition | NonFungiblePostCondition;
interface STXPostCondition {
    readonly type: StacksMessageType.PostCondition;
    readonly conditionType: PostConditionType.STX;
    readonly principal: PostConditionPrincipal;
    readonly conditionCode: FungibleConditionCode;
    readonly amount: bigint;
}
declare function createSTXPostCondition(principal: string | PostConditionPrincipal, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
interface FungiblePostCondition {
    readonly type: StacksMessageType.PostCondition;
    readonly conditionType: PostConditionType.Fungible;
    readonly principal: PostConditionPrincipal;
    readonly conditionCode: FungibleConditionCode;
    readonly amount: bigint;
    readonly assetInfo: AssetInfo;
}
declare function createFungiblePostCondition(principal: string | PostConditionPrincipal, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
interface NonFungiblePostCondition {
    readonly type: StacksMessageType.PostCondition;
    readonly conditionType: PostConditionType.NonFungible;
    readonly principal: PostConditionPrincipal;
    readonly conditionCode: NonFungibleConditionCode;
    readonly assetInfo: AssetInfo;
    readonly assetName: ClarityValue;
}
declare function createNonFungiblePostCondition(principal: string | PostConditionPrincipal, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;
declare function serializePostCondition(postCondition: PostCondition): Uint8Array;
declare function deserializePostCondition(bufferReader: BufferReader): PostCondition;

declare type StacksMessage = Address | PostConditionPrincipal | LengthPrefixedString | LengthPrefixedList | Payload | MemoString | AssetInfo | PostCondition | StacksPublicKey | TransactionAuthField | MessageSignature;
declare function serializeStacksMessage(message: StacksMessage): Uint8Array;
declare function deserializeStacksMessage(bufferReader: BufferReader, type: StacksMessageType, listType?: StacksMessageType): StacksMessage;
declare function createEmptyAddress(): Address;
declare function addressFromVersionHash(version: StacksNetworkVersion, hash: string): Address;
declare function addressHashModeToVersion(hashMode: AddressHashMode, txVersion: TransactionVersion): StacksNetworkVersion;
declare function addressFromHashMode(hashMode: AddressHashMode, txVersion: TransactionVersion, data: string): Address;
declare function addressFromPublicKeys(version: StacksNetworkVersion, hashMode: AddressHashMode, numSigs: number, publicKeys: StacksPublicKey[]): Address;
declare function parsePrincipalString(principalString: string): StandardPrincipal | ContractPrincipal;
declare function createStandardPrincipal(addressString: string): StandardPrincipal;
declare function createContractPrincipal(addressString: string, contractName: string): ContractPrincipal;
declare function serializePrincipal(principal: PostConditionPrincipal): Uint8Array;
declare function deserializePrincipal(bufferReader: BufferReader): PostConditionPrincipal;
declare function codeBodyString(content: string): LengthPrefixedString;
interface MemoString {
    readonly type: StacksMessageType.MemoString;
    readonly content: string;
}
declare function createMemoString(content: string): MemoString;
declare function serializeMemoString(memoString: MemoString): Uint8Array;
declare function deserializeMemoString(bufferReader: BufferReader): MemoString;
declare function parseAssetInfoString(id: string): AssetInfo;
declare function createAssetInfo(addressString: string, contractName: string, assetName: string): AssetInfo;
declare function serializeAssetInfo(info: AssetInfo): Uint8Array;
declare function deserializeAssetInfo(bufferReader: BufferReader): AssetInfo;
interface LengthPrefixedList {
    readonly type: StacksMessageType.LengthPrefixedList;
    readonly lengthPrefixBytes: number;
    readonly values: StacksMessage[];
}
declare function createLPList<T extends StacksMessage>(values: T[], lengthPrefixBytes?: number): LengthPrefixedList;
declare function serializeLPList(lpList: LengthPrefixedList): Uint8Array;
declare function deserializeLPList(bufferReader: BufferReader, type: StacksMessageType, lengthPrefixBytes?: number): LengthPrefixedList;

declare type Payload = TokenTransferPayload | ContractCallPayload | SmartContractPayload | PoisonPayload | CoinbasePayload;
declare enum PayloadType {
    TokenTransfer = 0,
    SmartContract = 1,
    ContractCall = 2,
    PoisonMicroblock = 3,
    Coinbase = 4
}
interface TokenTransferPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.TokenTransfer;
    readonly recipient: PrincipalCV;
    readonly amount: bigint;
    readonly memo: MemoString;
}
declare type PayloadInput = (TokenTransferPayload | (Omit<TokenTransferPayload, 'amount'> & {
    amount: IntegerType;
})) | ContractCallPayload | SmartContractPayload | PoisonPayload | CoinbasePayload;
interface ContractCallPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.ContractCall;
    readonly contractAddress: Address;
    readonly contractName: LengthPrefixedString;
    readonly functionName: LengthPrefixedString;
    readonly functionArgs: ClarityValue[];
}
interface SmartContractPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.SmartContract;
    readonly contractName: LengthPrefixedString;
    readonly codeBody: LengthPrefixedString;
}
interface PoisonPayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.PoisonMicroblock;
}
interface CoinbasePayload {
    readonly type: StacksMessageType.Payload;
    readonly payloadType: PayloadType.Coinbase;
    readonly coinbaseBuffer: Uint8Array;
}

declare class StacksTransaction {
    version: TransactionVersion;
    chainId: ChainID;
    auth: Authorization;
    anchorMode: AnchorMode;
    payload: Payload;
    postConditionMode: PostConditionMode;
    postConditions: LengthPrefixedList;
    constructor(version: TransactionVersion, auth: Authorization, payload: PayloadInput, postConditions?: LengthPrefixedList, postConditionMode?: PostConditionMode, anchorMode?: AnchorMode, chainId?: ChainID);
    signBegin(): string;
    verifyBegin(): string;
    createTxWithSignature(signature: string | Uint8Array): StacksTransaction;
    verifyOrigin(): string;
    signNextOrigin(sigHash: string, privateKey: StacksPrivateKey): Promise<string>;
    signNextSponsor(sigHash: string, privateKey: StacksPrivateKey): Promise<string>;
    appendPubkey(publicKey: StacksPublicKey): void;
    signAndAppend(condition: SpendingConditionOpts, curSigHash: string, authType: AuthType, privateKey: StacksPrivateKey): Promise<string>;
    txid(): string;
    setSponsor(sponsorSpendingCondition: SpendingConditionOpts): void;
    setFee(amount: IntegerType): void;
    setNonce(nonce: IntegerType): void;
    setSponsorNonce(nonce: IntegerType): void;
    serialize(): Uint8Array;
}
declare function deserializeTransaction(data: BufferReader | Uint8Array | string): StacksTransaction;

declare const isClarityAbiPrimitive: (val: ClarityAbiType) => val is ClarityAbiTypePrimitive;
declare const isClarityAbiBuffer: (val: ClarityAbiType) => val is ClarityAbiTypeBuffer;
declare const isClarityAbiStringAscii: (val: ClarityAbiType) => val is ClarityAbiTypeStringAscii;
declare const isClarityAbiStringUtf8: (val: ClarityAbiType) => val is ClarityAbiTypeStringUtf8;
declare const isClarityAbiResponse: (val: ClarityAbiType) => val is ClarityAbiTypeResponse;
declare const isClarityAbiOptional: (val: ClarityAbiType) => val is ClarityAbiTypeOptional;
declare const isClarityAbiTuple: (val: ClarityAbiType) => val is ClarityAbiTypeTuple;
declare const isClarityAbiList: (val: ClarityAbiType) => val is ClarityAbiTypeList;
declare function getTypeUnion(val: ClarityAbiType): ClarityAbiTypeUnion;
declare function encodeClarityValue(type: ClarityAbiType, val: string): ClarityValue;
declare function encodeClarityValue(type: ClarityAbiTypeUnion, val: string): ClarityValue;

declare function getTypeString(val: ClarityAbiType): string;
declare function abiFunctionToString(func: ClarityAbiFunction): string;
declare function validateContractCall(payload: ContractCallPayload, abi: ClarityAbi): boolean;
declare function parseToCV(input: string, type: ClarityAbiType): ClarityValue;

declare class TransactionSigner {
    transaction: StacksTransaction;
    sigHash: string;
    originDone: boolean;
    checkOversign: boolean;
    checkOverlap: boolean;
    constructor(transaction: StacksTransaction);
    static createSponsorSigner(transaction: StacksTransaction, spendingCondition: SpendingConditionOpts): TransactionSigner;
    signOrigin(privateKey: StacksPrivateKey): Promise<void>;
    appendOrigin(publicKey: StacksPublicKey): void;
    signSponsor(privateKey: StacksPrivateKey): Promise<void>;
    getTxInComplete(): StacksTransaction;
    resume(transaction: StacksTransaction): void;
}

declare const leftPadHex: (hexString: string) => string;
declare const leftPadHexToLength: (hexString: string, length: number) => string;
declare const rightPadHexToLength: (hexString: string, length: number) => string;
declare const txidFromData: (data: Uint8Array) => string;
interface ReadOnlyFunctionSuccessResponse {
    okay: true;
    result: string;
}
interface ReadOnlyFunctionErrorResponse {
    okay: false;
    cause: string;
}
declare type ReadOnlyFunctionResponse = ReadOnlyFunctionSuccessResponse | ReadOnlyFunctionErrorResponse;
declare function parseReadOnlyResponse<T extends ClarityValue>(response: ReadOnlyFunctionResponse): T;

interface MultiSigOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys?: string[];
}
interface ContractCallOptions {
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: ClarityValue[];
    fee?: IntegerType;
    feeEstimateApiUrl?: string;
    nonce?: IntegerType;
    network?: StacksNetwork;
    anchorMode: AnchorMode;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    validateWithAbi?: boolean | ClarityAbi;
    sponsored?: boolean;
}
interface UnsignedContractCallOptions extends ContractCallOptions {
    publicKey: string;
}
interface SignedContractCallOptions extends ContractCallOptions {
    senderKey: string;
}
interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {
    numSignatures: number;
    publicKeys: string[];
}
interface SignedMultiSigContractCallOptions extends ContractCallOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
interface ContractDeployOptions {
    contractName: string;
    codeBody: string;
    senderKey: string;
    fee?: IntegerType;
    nonce?: IntegerType;
    network?: StacksNetwork;
    anchorMode: AnchorMode;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    sponsored?: boolean;
}
interface TokenTransferOptions {
    recipient: string | PrincipalCV;
    amount: IntegerType;
    fee?: IntegerType;
    nonce?: IntegerType;
    network?: StacksNetwork;
    anchorMode: AnchorMode;
    memo?: string;
    postConditionMode?: PostConditionMode;
    postConditions?: PostCondition[];
    sponsored?: boolean;
}
interface UnsignedTokenTransferOptions extends TokenTransferOptions {
    publicKey: string;
}
interface SignedTokenTransferOptions extends TokenTransferOptions {
    senderKey: string;
}
interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
}
interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {
    numSignatures: number;
    publicKeys: string[];
    signerKeys: string[];
}
interface SponsorOptionsOpts {
    transaction: StacksTransaction;
    sponsorPrivateKey: string;
    fee?: IntegerType;
    sponsorNonce?: IntegerType;
    sponsorAddressHashmode?: AddressHashMode;
    network?: StacksNetwork;
}

declare function sponsorTransaction(sponsorOptions: SponsorOptionsOpts): Promise<StacksTransaction>;

declare function makeStandardSTXPostCondition(address: string, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
declare function makeContractSTXPostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: IntegerType): STXPostCondition;
declare function makeStandardFungiblePostCondition(address: string, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
declare function makeContractFungiblePostCondition(address: string, contractName: string, conditionCode: FungibleConditionCode, amount: IntegerType, assetInfo: string | AssetInfo): FungiblePostCondition;
declare function makeStandardNonFungiblePostCondition(address: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;
declare function makeContractNonFungiblePostCondition(address: string, contractName: string, conditionCode: NonFungibleConditionCode, assetInfo: string | AssetInfo, assetName: ClarityValue): NonFungiblePostCondition;

declare function makeUnsignedContractCall(txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions): Promise<StacksTransaction>;
declare function makeContractCall(txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions): Promise<StacksTransaction>;

declare function makeContractDeploy(txOptions: ContractDeployOptions): Promise<StacksTransaction>;

declare function makeUnsignedSTXTokenTransfer(txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions, sync?: boolean): Promise<StacksTransaction>;
declare function makeSTXTokenTransfer(txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions): Promise<StacksTransaction>;

declare type TxBroadcastResultOk = {
    txid: string;
};
declare type TxBroadcastResultRejected = {
    error: string;
    reason: TxRejectedReason;
    reason_data: any;
    txid: string;
};
declare type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;
declare function broadcastTransaction(transaction: StacksTransaction, network: StacksNetwork, attachment?: Uint8Array): Promise<TxBroadcastResult>;
declare function broadcastRawTransaction(rawTx: Uint8Array, url: string, attachment?: Uint8Array): Promise<TxBroadcastResult>;

declare function getNonce(address: string, network?: StacksNetwork): Promise<bigint>;

declare function estimateTransfer(transaction: StacksTransaction, network?: StacksNetwork): Promise<bigint>;

declare function getAbi(address: string, contractName: string, network: StacksNetwork): Promise<ClarityAbi>;

declare function estimateContractFunctionCall(transaction: StacksTransaction, network?: StacksNetwork): Promise<bigint>;

declare function estimateContractDeploy(transaction: StacksTransaction, network?: StacksNetwork): Promise<bigint>;

export { AddressHashMode, AddressVersion, AnchorMode, AssetType, AuthType, Authorization, CLARITY_INT_BYTE_SIZE, ContractCallOptions, ContractDeployOptions, DEFAULT_CORE_NODE_API_URL, DEFAULT_TRANSACTION_VERSION, Deserializable, FungibleConditionCode, LengthPrefixedList, MemoString, MessageSignature, MultiSigHashMode, MultiSigOptions, MultiSigSpendingCondition, MultiSigSpendingConditionOpts, NonFungibleConditionCode, PostCondition, PostConditionMode, PostConditionType, PubKeyEncoding, ReadOnlyFunctionErrorResponse, ReadOnlyFunctionResponse, ReadOnlyFunctionSuccessResponse, SignedContractCallOptions, SignedMultiSigContractCallOptions, SignedMultiSigTokenTransferOptions, SignedTokenTransferOptions, SingleSigHashMode, SingleSigSpendingCondition, SingleSigSpendingConditionOpts, SpendingCondition, SpendingConditionOpts, SponsorOptionsOpts, SponsoredAuthorization, StacksMessage, StacksPrivateKey, StacksPublicKey, StacksTransaction, StandardAuthorization, TokenTransferOptions, TransactionAuthField, TransactionAuthFieldContents, TransactionSigner, TxBroadcastResult, TxBroadcastResultOk, TxBroadcastResultRejected, TxRejectedReason, UnsignedContractCallOptions, UnsignedMultiSigContractCallOptions, UnsignedMultiSigTokenTransferOptions, UnsignedTokenTransferOptions, abiFunctionToString, addressFromHashMode, addressFromPublicKeys, addressFromVersionHash, addressHashModeToVersion, broadcastRawTransaction, broadcastTransaction, codeBodyString, compressPublicKey, createAssetInfo, createContractPrincipal, createEmptyAddress, createFungiblePostCondition, createLPList, createMemoString, createMessageSignature, createMultiSigSpendingCondition, createNonFungiblePostCondition, createSTXPostCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStacksPrivateKey, createStacksPublicKey, createStandardAuth, createStandardPrincipal, createTransactionAuthField, deserializeAssetInfo, deserializeAuthorization, deserializeLPList, deserializeMemoString, deserializeMessageSignature, deserializeMultiSigSpendingCondition, deserializePostCondition, deserializePrincipal, deserializePublicKey, deserializeSingleSigSpendingCondition, deserializeSpendingCondition, deserializeStacksMessage, deserializeTransaction, deserializeTransactionAuthField, emptyMessageSignature, encodeClarityValue, estimateContractDeploy, estimateContractFunctionCall, estimateTransfer, getAbi, getFee, getNonce, getPublicKeyFromStacksPrivateKey, getSignatureRecoveryParam, getTypeString, getTypeUnion, intoInitialSighashAuth, isClarityAbiBuffer, isClarityAbiList, isClarityAbiOptional, isClarityAbiPrimitive, isClarityAbiResponse, isClarityAbiStringAscii, isClarityAbiStringUtf8, isClarityAbiTuple, isCompressed, isPrivateKeyCompressed, isSingleSig, leftPadHex, leftPadHexToLength, makeContractCall, makeContractDeploy, makeContractFungiblePostCondition, makeContractNonFungiblePostCondition, makeContractSTXPostCondition, makeRandomPrivKey, makeSTXTokenTransfer, makeSigHashPreSign, makeStandardFungiblePostCondition, makeStandardNonFungiblePostCondition, makeStandardSTXPostCondition, makeUnsignedContractCall, makeUnsignedSTXTokenTransfer, nextSignature, nextVerification, parseAssetInfoString, parsePrincipalString, parseReadOnlyResponse, parseRecoverableSignature, parseToCV, privateKeyToString, pubKeyfromPrivKey, publicKeyFromBuffer, publicKeyFromSignature, publicKeyToString, rightPadHexToLength, serializeAssetInfo, serializeAuthorization, serializeLPList, serializeMemoString, serializeMessageSignature, serializeMultiSigSpendingCondition, serializePostCondition, serializePrincipal, serializePublicKey, serializeSingleSigSpendingCondition, serializeSpendingCondition, serializeStacksMessage, serializeTransactionAuthField, setFee, setNonce, setSponsor, setSponsorNonce, signWithKey, sponsorTransaction, txidFromData, validateContractCall, verifyOrigin };
