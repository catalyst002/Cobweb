import { validateMnemonic, mnemonicToEntropy, generateMnemonic, mnemonicToSeed, entropyToMnemonic } from '@scure/bip39';
import { HDKey, HARDENED_OFFSET } from '@scure/bip32';
import { wordlist } from '@scure/bip39/wordlists/english';
import { bytesToHex, utf8ToBytes, concatByteArrays, hexToBytes } from 'micro-stacks/common';
import { hashSha256 } from 'micro-stacks/crypto-sha';
import { getRandomBytes, privateKeyToStxAddress, StacksNetworkVersion, publicKeyToBase58Address, getPublicKey, encryptECIES, publicKeyToStxAddress, TokenSigner } from 'micro-stacks/crypto';
import { aes128CbcEncrypt, aes128CbcDecrypt } from 'micro-stacks/crypto-aes';
import { hmacSha256 } from 'micro-stacks/crypto-hmac-sha';
import { createPbkdf2 } from 'micro-stacks/crypto-pbkdf2';
import { generateGaiaHubConfig, getFile, putFile } from 'micro-stacks/storage';

var A="m/888'/0'",S="m/44/5757'/0'/1",_="m/44'/5757'/0'/0",v="wallet-config.json",I="https://hub.blockstack.org";function D(e){return e.length===32||e.length===33&&(e[0]===2||e[0]===3)}function p(e){return e+HARDENED_OFFSET}var U=e=>{let t=e.derive(S).privateKey;if(!t)throw new TypeError("Unable to derive config key for wallet identities");return bytesToHex(t)},te=e=>{let o=HDKey.fromExtendedKey(e).deriveChild(p(45)).privateKey;if(!o)throw new TypeError("Unable to derive config key for wallet identities");return bytesToHex(o)};function N(e){let t=e.derive(A).publicKey;if(!t)throw new TypeError("Unable to derive public key from data derivation path");return bytesToHex(hashSha256(utf8ToBytes(bytesToHex(t))))}function b(e){if(!e.privateKey)throw Error("no private key");let t=N(e),r=e.privateExtendedKey,o=U(e);return {salt:t,rootKey:r,configPrivateKey:o}}async function T(e,t,r=getRandomBytes(16)){if(!validateMnemonic(e,wordlist))throw new Error("Not a valid bip39 mnemonic");let o=await createPbkdf2(),i=mnemonicToEntropy(e,wordlist),n=await o.derive(t,r,1e5,48,"sha512"),a=n.slice(0,16),s=n.slice(16,32),c=n.slice(32,48),f=await aes128CbcEncrypt(c,a,i),m=concatByteArrays([r,f]),y=hmacSha256(s,m);return concatByteArrays([r,y,f])}function P(e,t,r){let o=e.derive(_).deriveChild(t);if(!o.privateKey)throw Error("no private key");let n=e.derive(A).deriveChild(p(t));if(!n.privateKey)throw new Error("Must have private key to derive identities");let a=bytesToHex(n.privateKey),s=n.deriveChild(p(0)).privateExtendedKey;return {stxPrivateKey:`${bytesToHex(o.privateKey)}${D(o.privateKey)?"01":""}`,dataPrivateKey:a,appsKey:s,salt:r,index:t}}function w(e){return P(HDKey.fromExtendedKey(e.rootKey),e.accounts.length,e.salt)}function H(e,t,r){let o=[],i=[...Array(t).keys()];for(let n of i){let s=(r||(e.accounts.length>0?e.accounts.length-1:0))+n;e.accounts[s]||o.push(P(HDKey.fromExtendedKey(e.rootKey),s,e.salt));}return o}function ye(e=256){if(e!==256&&e!==128)throw TypeError(`Incorrect entropy bits provided, expected 256 or 128 (24 or 12 word results), got: "${String(e)}".`);return generateMnemonic(wordlist,e)}async function ue(e,t){let[r,o]=await Promise.all([mnemonicToSeed(e),T(e,t)]),i=bytesToHex(o),n=b(HDKey.fromMasterSeed(r));return L({...n,encryptedSecretKey:i,accounts:[]})}function L(e){return {...e,accounts:[...e.accounts,w(e)]}}function xe(e,t=StacksNetworkVersion.mainnetP2PKH){let r=e.stxPrivateKey.endsWith("01");return privateKeyToStxAddress(e.stxPrivateKey.slice(0,64),t,r)}var Ae={private:76066276,public:76067358};function ve(e){let t=0;if(e.length===0)return t;for(let r=0;r<e.length;r++){let o=e.charCodeAt(r);t=(t<<5)-t+o,t&=t;}return t&2147483647}function he(e,t,r=!0){if(r)return Ke(e,t);let o=hashSha256(utf8ToBytes(`${t}${e.salt}`)),i=HDKey.fromExtendedKey(e.appsKey);if(!i.privateKey)throw Error("no rootNode.privateKey");let n=new HDKey({privateKey:i.privateKey,chainCode:o,versions:Ae}).deriveChild(p(0));if(!n.privateKey)throw new Error("[micro-stacks/wallet-sdk] getAppPrivateKey: No private key found");return bytesToHex(n.privateKey)}function Ke(e,t){let r=bytesToHex(hashSha256(utf8ToBytes(`${t}${e.salt}`))),o=ve(r),i=HDKey.fromExtendedKey(e.appsKey).deriveChild(p(o));if(!i.privateKey)throw new Error("[micro-stacks/wallet-sdk] getLegacyAppPrivateKey: No private key found");return bytesToHex(i.privateKey)}function be(e){let t=e.stxPrivateKey.endsWith("01");return publicKeyToBase58Address(getPublicKey(e.dataPrivateKey,t))}async function _e(e,t){let r=typeof e=="string"?hexToBytes(e):e,o=r.slice(0,16),i=r.slice(16,48),n=r.slice(48),a=concatByteArrays([o,n]),c=await(await createPbkdf2()).derive(t,o,1e5,48,"sha512"),f=c.slice(0,16),m=c.slice(16,32),y=c.slice(32,48),d=await aes128CbcDecrypt(y,f,n),W=hmacSha256(m,a),g=hashSha256(i),x=hashSha256(W);if(bytesToHex(g)!==bytesToHex(x))throw new Error("Wrong password (HMAC mismatch)");let l;try{l=entropyToMnemonic(d,wordlist);}catch(C){throw console.error("Error thrown by `entropyToMnemonic`"),console.error(C),new Error("Wrong password (invalid plaintext)")}if(!validateMnemonic(l,wordlist))throw new Error("Wrong password (invalid plaintext)");return l}function Fe(e){return `did:btc-addr:${e}`}function Oe(){return new Date(new Date().setMonth(new Date().getMonth()+1))}function Le(){let e=new Date().getTime();return typeof performance<"u"&&typeof performance.now=="function"&&(e+=performance.now()),"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{let r=(e+Math.random()*16)%16|0;return e=Math.floor(e/16),(t==="x"?r:r&3|8).toString(16)})}async function j(e,t){let r=await encryptECIES({content:hexToBytes(t),publicKey:e,cipherTextEncoding:"hex",wasString:!1}),o=JSON.stringify(r);return bytesToHex(utf8ToBytes(o))}async function Rt(e){let{expiresAt:t}=e,{privateKey:r,appPrivateKey:o,coreToken:i,transitPublicKey:n,metadata:a,hubUrl:s,blockstackAPIUrl:c,associationToken:f,username:m,profile:y}=e,d=bytesToHex(getPublicKey(r)),W=publicKeyToStxAddress(d);t||(t=Oe().getTime());let g=o,x=i,l={};o!=null&&(n!=null&&(g=await j(n,o),i!=null&&(x=await j(n,i))),l={email:a!=null&&a.email?a.email:null,profile_url:a!=null&&a.profileUrl?a.profileUrl:null,hubUrl:s,blockstackAPIUrl:c,associationToken:f,version:"undefined"});let C={jti:Le(),iat:Math.floor(new Date().getTime()/1e3),exp:Math.floor(t/1e3),iss:Fe(W),private_key:g??null,public_keys:[d],profile:y??null,username:m??null,core_token:x??null,...l};return new TokenSigner("ES256k",r).sign(C)}function K(e,t=I){return generateGaiaHubConfig({gaiaHubUrl:t,privateKey:e})}async function q(e,t){try{let r=t==null?void 0:t.gaiaHubConfig;r||(r=await K(e,t==null?void 0:t.gaiaHubUrl));let o=await getFile(v,{privateKey:e,gaiaHubConfig:r});if(typeof o!="string"){console.error("Wallet config response should be of type string");return}return JSON.parse(o)}catch{}}function z(e){return {accounts:e.accounts.map(t=>({username:t.username,apps:{}}))}}async function u({walletConfig:e,privateKey:t,gaiaHubConfig:r,gaiaHubUrl:o}){r||(r=await K(t,o)),await putFile(v,JSON.stringify(e),{gaiaHubConfig:r,privateKey:t,encrypt:!0,sign:!0});}async function sr({wallet:e,gaiaHubConfig:t,gaiaHubUrl:r}){let o=await q(e.configPrivateKey,{gaiaHubConfig:t,gaiaHubUrl:r});return o||(o=z(e),await u({walletConfig:o,gaiaHubConfig:t,gaiaHubUrl:r,privateKey:e.configPrivateKey})),o}function fr({wallet:e,walletConfig:t}){if(!t||t.accounts.length===0)return e;let r=t.accounts.length,o=H(e,r);return {...e,accounts:o}}function $e({wallet:e,walletConfig:t,app:r,account:o}){for(let i of e.accounts){let n=0,a=t.accounts[n];if(a?(a.apps=a.apps||{},a.username=i==null?void 0:i.username,t.accounts[n]=a):t.accounts.push({username:i==null?void 0:i.username,apps:{}}),n===o.index){let s=t.accounts[n];s.apps=s.apps||{},s.apps[r.origin]=r,t.accounts[n]=s;}n+=1;}return t}var yr=async({wallet:e,account:t,app:r,walletConfig:o,gaiaHubConfig:i})=>{let n=$e({wallet:e,walletConfig:o,app:r,account:t});return await u({walletConfig:n,gaiaHubConfig:i,privateKey:e.configPrivateKey}),o},ur=async({wallet:e,walletConfig:t,gaiaHubConfig:r})=>{let o={...t,accounts:[...t.accounts,{apps:{}}]};return await u({walletConfig:o,gaiaHubConfig:r,privateKey:e.configPrivateKey}),t};

export { ur as addNewAccountToWalletConfig, K as createWalletConfigGaiaHubConfig, _e as decryptMnemonic, P as deriveAccount, U as deriveConfigPrivateKey, te as deriveLegacyConfigPrivateKey, H as deriveManyAccountsForWallet, w as deriveNextAccountFromWallet, N as deriveSalt, b as deriveWalletKeys, T as encryptMnemonic, j as encryptPrivateKey, q as fetchWalletConfig, L as generateAndInsertNewAccount, ye as generateSecretKey, ue as generateWallet, he as getAppPrivateKey, be as getGaiaAddress, sr as getOrSetWalletConfig, xe as getStxAddressFromAccount, Rt as makeAuthResponse, Fe as makeDIDFromAddress, Le as makeUUID4, z as makeWalletConfig, Oe as nextMonth, fr as restoreWalletAccountsFromWalletConfig, u as saveWalletConfig, yr as updateWalletConfigWithApp };
