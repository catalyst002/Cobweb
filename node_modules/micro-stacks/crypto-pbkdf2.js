'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cryptoAes = require('micro-stacks/crypto-aes');
var common = require('micro-stacks/common');
var pbkdf2 = require('@noble/hashes/pbkdf2');
var sha512 = require('@noble/hashes/sha512');

var m=class{nodePbkdf2;constructor(r){this.nodePbkdf2=r;}async derive(r,o,i,s,t){if(t!=="sha512"&&t!=="sha256")throw new Error(`Unsupported digest "${t}" for Pbkdf2`);return new Promise((n,p)=>{this.nodePbkdf2(r,o,i,s,t,(f,d)=>{f&&p(f),n(d);});})}};var b=class{webCrypto;constructor(r){this.webCrypto=r;}async derive(r,o,i,s,t){let n;if(t==="sha256")n="SHA-256";else if(t==="sha512")n="SHA-512";else throw new Error(`Unsupported Pbkdf2 digest algorithm "${t}"`);let p=await this.webCrypto.subtle.importKey("raw",common.utf8ToBytes(r),"PBKDF2",!1,["deriveBits"]),f=await this.webCrypto.subtle.deriveBits({name:"PBKDF2",salt:o,iterations:i,hash:{name:n}},p,s*8);return new Uint8Array(f)}};async function v(){try{let e=await cryptoAes.getCryptoLib();return e.name==="webCrypto"?new b(e.lib):new m(e.lib.pbkdf2)}catch{return {derive(r,o,i,s,t="sha512"){return pbkdf2.pbkdf2Async(sha512.sha512,common.ensureUint8Array(common.utf8ToBytes(r)),common.ensureUint8Array(o),{c:i,dkLen:s})}}}}

exports.createPbkdf2 = v;
