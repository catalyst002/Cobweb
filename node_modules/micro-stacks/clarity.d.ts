import { IntegerType, BufferReader } from 'micro-stacks/common';
import { StacksNetworkVersion } from 'micro-stacks/crypto';

declare const MAX_STRING_LENGTH_BYTES = 128;
declare const CLARITY_INT_SIZE = 128;
declare const MAX_U128: bigint;
declare const MIN_U128: bigint;
declare const MAX_I128: bigint;
declare const MIN_I128: bigint;
declare const COINBASE_BUFFER_LENGTH_BYTES = 32;
declare const RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;
declare const COMPRESSED_PUBKEY_LENGTH_BYTES = 32;
declare const UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;
declare const MEMO_MAX_LENGTH_BYTES = 34;
declare enum PostConditionPrincipalID {
    Origin = 1,
    Standard = 2,
    Contract = 3
}
declare enum ClarityType {
    Int = 0,
    UInt = 1,
    Buffer = 2,
    BoolTrue = 3,
    BoolFalse = 4,
    PrincipalStandard = 5,
    PrincipalContract = 6,
    ResponseOk = 7,
    ResponseErr = 8,
    OptionalNone = 9,
    OptionalSome = 10,
    List = 11,
    Tuple = 12,
    StringASCII = 13,
    StringUTF8 = 14
}

declare type BooleanCV = TrueCV | FalseCV;
interface TrueCV {
    type: ClarityType.BoolTrue;
}
interface FalseCV {
    type: ClarityType.BoolFalse;
}
declare const trueCV: () => BooleanCV;
declare const falseCV: () => BooleanCV;
declare const boolCV: (value: boolean) => BooleanCV;

interface BufferCV {
    readonly type: ClarityType.Buffer;
    readonly buffer: Uint8Array;
}
declare const bufferCV: (buffer: Uint8Array) => BufferCV;
declare const bufferCVFromString: (string: string) => BufferCV;

interface IntCV {
    readonly type: ClarityType.Int;
    readonly value: bigint;
}
declare const intCV: (value: IntegerType) => IntCV;
interface UIntCV {
    readonly type: ClarityType.UInt;
    readonly value: bigint;
}
declare const uintCV: (value: IntegerType) => UIntCV;

declare function isClarityName(name: string): boolean;
declare enum StacksMessageType {
    Address = 0,
    Principal = 1,
    LengthPrefixedString = 2,
    MemoString = 3,
    AssetInfo = 4,
    PostCondition = 5,
    PublicKey = 6,
    LengthPrefixedList = 7,
    Payload = 8,
    MessageSignature = 9,
    TransactionAuthField = 10
}
interface Address {
    readonly type: StacksMessageType.Address;
    readonly version: StacksNetworkVersion;
    readonly hash160: string;
}
declare function createAddress(c32AddressString: string): Address;
declare function addressToString(address: Address): string;
interface LengthPrefixedString {
    readonly type: StacksMessageType.LengthPrefixedString;
    readonly content: string;
    readonly lengthPrefixBytes: number;
    readonly maxLengthBytes: number;
}
declare const exceedsMaxLengthBytes: (string: string, maxLengthBytes: number) => boolean;
declare function createLPString(content: string): LengthPrefixedString;
declare function createLPString(content: string, lengthPrefixBytes: number): LengthPrefixedString;
declare function createLPString(content: string, lengthPrefixBytes: number, maxLengthBytes: number): LengthPrefixedString;
declare function serializeAddress(address: Address): Uint8Array;
declare function serializeLPString(lps: LengthPrefixedString): Uint8Array;
declare function deserializeLPString(bufferReader: BufferReader, prefixBytes?: number, maxLength?: number): LengthPrefixedString;
declare function deserializeAddress(bufferReader: BufferReader): Address;
interface StandardPrincipal {
    readonly type: StacksMessageType.Principal;
    readonly prefix: PostConditionPrincipalID.Standard;
    readonly address: Address;
}
interface ContractPrincipal {
    readonly type: StacksMessageType.Principal;
    readonly prefix: PostConditionPrincipalID.Contract;
    readonly address: Address;
    readonly contractName: LengthPrefixedString;
}
declare type PostConditionPrincipal = StandardPrincipal | ContractPrincipal;
interface AssetInfo {
    readonly type: StacksMessageType.AssetInfo;
    readonly address: Address;
    readonly contractName: LengthPrefixedString;
    readonly assetName: LengthPrefixedString;
}

declare type PrincipalCV = StandardPrincipalCV | ContractPrincipalCV;
interface StandardPrincipalCV {
    readonly type: ClarityType.PrincipalStandard;
    readonly address: Address;
}
interface ContractPrincipalCV {
    readonly type: ClarityType.PrincipalContract;
    readonly address: Address;
    readonly contractName: LengthPrefixedString;
}
declare function principalToString(principal: PrincipalCV): string;
declare function principalCV(principal: string): PrincipalCV;
declare function standardPrincipalCV(addressString: string): StandardPrincipalCV;
declare function standardPrincipalCVFromAddress(address: Address): StandardPrincipalCV;
declare function contractPrincipalCV(addressOrContractId: string, contractName?: string): ContractPrincipalCV;
declare function contractPrincipalCVFromAddress(address: Address, contractName: LengthPrefixedString): ContractPrincipalCV;
declare function contractPrincipalCVFromStandard(sp: StandardPrincipalCV, contractName: string): ContractPrincipalCV;

declare type ResponseCV = ResponseErrorCV | ResponseOkCV;
interface ResponseErrorCV<T extends ClarityValue = ClarityValue> {
    readonly type: ClarityType.ResponseErr;
    readonly value: T;
}
interface ResponseOkCV<T extends ClarityValue = ClarityValue> {
    readonly type: ClarityType.ResponseOk;
    readonly value: T;
}
declare function responseErrorCV<T extends ClarityValue = ClarityValue>(value: T): ResponseErrorCV<T>;
declare function responseOkCV<T extends ClarityValue = ClarityValue>(value: T): ResponseOkCV<T>;

declare type OptionalCV<T extends ClarityValue> = NoneCV | SomeCV<T>;
interface NoneCV {
    readonly type: ClarityType.OptionalNone;
}
interface SomeCV<T extends ClarityValue = ClarityValue> {
    readonly type: ClarityType.OptionalSome;
    readonly value: T;
}
declare function noneCV(): NoneCV;
declare function someCV<T extends ClarityValue = ClarityValue>(value: T): OptionalCV<T>;
declare function optionalCVOf<T extends ClarityValue = ClarityValue>(value?: T): OptionalCV<T>;

declare type TupleData<T extends ClarityValue = ClarityValue> = {
    [key: string]: T;
};
interface TupleCV<T extends TupleData = TupleData> {
    type: ClarityType.Tuple;
    data: T;
}
declare function tupleCV<T extends ClarityValue = ClarityValue>(data: TupleData<T>): TupleCV<TupleData<T>>;

interface StringAsciiCV {
    readonly type: ClarityType.StringASCII;
    readonly data: string;
}
interface StringUtf8CV {
    readonly type: ClarityType.StringUTF8;
    readonly data: string;
}
declare const stringAsciiCV: (data: string) => StringAsciiCV;
declare const stringUtf8CV: (data: string) => StringUtf8CV;
declare const stringCV: (data: string, encoding: 'ascii' | 'utf8') => StringAsciiCV | StringUtf8CV;

declare type ClarityValue = BooleanCV | BufferCV | IntCV | UIntCV | StandardPrincipalCV | ContractPrincipalCV | ResponseErrorCV | ResponseOkCV | NoneCV | SomeCV | ListCV | TupleCV | StringAsciiCV | StringUtf8CV;

interface ListCV<T extends ClarityValue = ClarityValue> {
    type: ClarityType.List;
    list: T[];
}
declare function listCV<T extends ClarityValue = ClarityValue>(values: T[]): ListCV<T>;

declare type ClarityAbiTypeBuffer = {
    buffer: {
        length: number;
    };
};
declare type ClarityAbiTypeStringAscii = {
    'string-ascii': {
        length: number;
    };
};
declare type ClarityAbiTypeStringUtf8 = {
    'string-utf8': {
        length: number;
    };
};
declare type ClarityAbiTypeResponse = {
    response: {
        ok: ClarityAbiType;
        error: ClarityAbiType;
    };
};
declare type ClarityAbiTypeOptional = {
    optional: ClarityAbiType;
};
declare type ClarityAbiTypeTuple = {
    tuple: {
        name: string;
        type: ClarityAbiType;
    }[];
};
declare type ClarityAbiTypeList = {
    list: {
        type: ClarityAbiType;
        length: number;
    };
};
declare type ClarityAbiTypeUInt128 = 'uint128';
declare type ClarityAbiTypeInt128 = 'int128';
declare type ClarityAbiTypeBool = 'bool';
declare type ClarityAbiTypePrincipal = 'principal';
declare type ClarityAbiTypeTraitReference = 'trait_reference';
declare type ClarityAbiTypeNone = 'none';
declare type ClarityAbiTypePrimitive = ClarityAbiTypeUInt128 | ClarityAbiTypeInt128 | ClarityAbiTypeBool | ClarityAbiTypePrincipal | ClarityAbiTypeTraitReference | ClarityAbiTypeNone;
declare type ClarityAbiType = ClarityAbiTypePrimitive | ClarityAbiTypeBuffer | ClarityAbiTypeResponse | ClarityAbiTypeOptional | ClarityAbiTypeTuple | ClarityAbiTypeList | ClarityAbiTypeStringAscii | ClarityAbiTypeStringUtf8 | ClarityAbiTypeTraitReference;
declare enum ClarityAbiTypeId {
    ClarityAbiTypeUInt128 = 1,
    ClarityAbiTypeInt128 = 2,
    ClarityAbiTypeBool = 3,
    ClarityAbiTypePrincipal = 4,
    ClarityAbiTypeNone = 5,
    ClarityAbiTypeBuffer = 6,
    ClarityAbiTypeResponse = 7,
    ClarityAbiTypeOptional = 8,
    ClarityAbiTypeTuple = 9,
    ClarityAbiTypeList = 10,
    ClarityAbiTypeStringAscii = 11,
    ClarityAbiTypeStringUtf8 = 12,
    ClarityAbiTypeTraitReference = 13
}
declare type ClarityAbiTypeUnion = {
    id: ClarityAbiTypeId.ClarityAbiTypeUInt128;
    type: ClarityAbiTypeUInt128;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeInt128;
    type: ClarityAbiTypeInt128;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeBool;
    type: ClarityAbiTypeBool;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypePrincipal;
    type: ClarityAbiTypePrincipal;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeTraitReference;
    type: ClarityAbiTypeTraitReference;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeNone;
    type: ClarityAbiTypeNone;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeBuffer;
    type: ClarityAbiTypeBuffer;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeResponse;
    type: ClarityAbiTypeResponse;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeOptional;
    type: ClarityAbiTypeOptional;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeTuple;
    type: ClarityAbiTypeTuple;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeList;
    type: ClarityAbiTypeList;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeStringAscii;
    type: ClarityAbiTypeStringAscii;
} | {
    id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8;
    type: ClarityAbiTypeStringUtf8;
};
interface ClarityAbiFunction {
    name: string;
    access: 'private' | 'public' | 'read_only';
    args: {
        name: string;
        type: ClarityAbiType;
    }[];
    outputs: {
        type: ClarityAbiType;
    };
}
interface ClarityAbiVariable {
    name: string;
    access: 'variable' | 'constant';
    type: ClarityAbiType;
}
interface ClarityAbiMap {
    name: string;
    key: {
        name: string;
        type: ClarityAbiType;
    }[];
    value: {
        name: string;
        type: ClarityAbiType;
    }[];
}
interface ClarityAbiTypeFungibleToken {
    name: string;
}
interface ClarityAbiTypeNonFungibleToken {
    name: string;
    type: ClarityAbiType;
}
interface ClarityAbi {
    functions: ClarityAbiFunction[];
    variables: ClarityAbiVariable[];
    maps: ClarityAbiMap[];
    fungible_tokens: ClarityAbiTypeFungibleToken[];
    non_fungible_tokens: ClarityAbiTypeNonFungibleToken[];
}

declare function cvToString(val: ClarityValue, encoding?: 'tryAscii' | 'hex'): string | bigint;

declare function cvToValue<T = any>(val: ClarityValue, strictJsonCompat?: boolean): T;

declare function cvToTrueValue<T = unknown>(val: ClarityValue, strictJsonCompat?: boolean): T;

interface CvToJsonResponseErr {
    type: string;
    value: any;
    success: false;
}
interface CvToJsonResponseOk {
    type: string;
    value: any;
    success: true;
}
interface CvToJsonCvObject {
    type: string;
    value: any;
}
declare function cvToJSON(val: ResponseOkCV): CvToJsonResponseOk;
declare function cvToJSON(val: ResponseErrorCV): CvToJsonResponseErr;
declare function cvToJSON(val: ClarityValue): CvToJsonCvObject;

declare function cvToHex(cv: ClarityValue): string;
declare function hexToCV<T extends ClarityValue>(hex: string): T;
declare function hexToCvValue<T>(hex: string, jsonCompat?: boolean): T;
declare function hexToValue<T>(hex: string, jsonCompat?: boolean): T;

declare function getCVTypeString(val: ClarityValue): string;

declare function deserializeCV<T extends ClarityValue = ClarityValue>(serializedClarityValue: BufferReader | Uint8Array | string): T;

declare function serializeCV(value: ClarityValue): Uint8Array;

export { Address, AssetInfo, BooleanCV, BufferCV, CLARITY_INT_SIZE, COINBASE_BUFFER_LENGTH_BYTES, COMPRESSED_PUBKEY_LENGTH_BYTES, ClarityAbi, ClarityAbiFunction, ClarityAbiMap, ClarityAbiType, ClarityAbiTypeBool, ClarityAbiTypeBuffer, ClarityAbiTypeFungibleToken, ClarityAbiTypeId, ClarityAbiTypeInt128, ClarityAbiTypeList, ClarityAbiTypeNonFungibleToken, ClarityAbiTypeNone, ClarityAbiTypeOptional, ClarityAbiTypePrimitive, ClarityAbiTypePrincipal, ClarityAbiTypeResponse, ClarityAbiTypeStringAscii, ClarityAbiTypeStringUtf8, ClarityAbiTypeTraitReference, ClarityAbiTypeTuple, ClarityAbiTypeUInt128, ClarityAbiTypeUnion, ClarityAbiVariable, ClarityType, ClarityValue, ContractPrincipal, ContractPrincipalCV, CvToJsonCvObject, CvToJsonResponseErr, CvToJsonResponseOk, FalseCV, IntCV, LengthPrefixedString, ListCV, MAX_I128, MAX_STRING_LENGTH_BYTES, MAX_U128, MEMO_MAX_LENGTH_BYTES, MIN_I128, MIN_U128, NoneCV, OptionalCV, PostConditionPrincipal, PostConditionPrincipalID, PrincipalCV, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, ResponseCV, ResponseErrorCV, ResponseOkCV, SomeCV, StacksMessageType, StandardPrincipal, StandardPrincipalCV, StringAsciiCV, StringUtf8CV, TrueCV, TupleCV, UIntCV, UNCOMPRESSED_PUBKEY_LENGTH_BYTES, addressToString, boolCV, bufferCV, bufferCVFromString, contractPrincipalCV, contractPrincipalCVFromAddress, contractPrincipalCVFromStandard, createAddress, createLPString, cvToHex, cvToJSON, cvToString, cvToTrueValue, cvToValue, deserializeAddress, deserializeCV, deserializeLPString, exceedsMaxLengthBytes, falseCV, getCVTypeString, hexToCV, hexToCvValue, hexToValue, intCV, isClarityName, listCV, noneCV, optionalCVOf, principalCV, principalToString, responseErrorCV, responseOkCV, serializeAddress, serializeCV, serializeLPString, someCV, standardPrincipalCV, standardPrincipalCVFromAddress, stringAsciiCV, stringCV, stringUtf8CV, trueCV, tupleCV, uintCV };
